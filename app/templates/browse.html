<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browse - XtreamFilter</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); min-height: 100vh; color: #e0e0e0; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px; flex-wrap: wrap; gap: 15px; }
        .header h1 { color: #00d4ff; font-size: 2em; text-shadow: 0 0 20px rgba(0, 212, 255, 0.3); }
        .btn { display: inline-block; padding: 10px 20px; border: none; border-radius: 8px; font-size: 0.95em; cursor: pointer; transition: all 0.3s; text-decoration: none; }
        .btn-secondary { background: rgba(255, 255, 255, 0.1); color: #fff; border: 1px solid rgba(255, 255, 255, 0.2); }
        .btn-secondary:hover { background: rgba(255, 255, 255, 0.2); }
        .btn-primary { background: linear-gradient(135deg, #00d4ff, #0099cc); color: #000; font-weight: 600; }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(0, 212, 255, 0.4); }
        .btn-small { padding: 6px 12px; font-size: 0.85em; }
        .btn-danger { background: rgba(255, 71, 87, 0.2); color: #ff4757; border: 1px solid rgba(255, 71, 87, 0.3); }
        .main-tabs { display: flex; gap: 5px; margin-bottom: 20px; flex-wrap: wrap; }
        .main-tab { padding: 12px 25px; background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; color: #888; cursor: pointer; transition: all 0.2s; font-size: 0.95em; }
        .main-tab:hover { color: #fff; background: rgba(255, 255, 255, 0.1); }
        .main-tab.active { background: rgba(0, 212, 255, 0.15); border-color: #00d4ff; color: #00d4ff; }
        .categories-section { background: rgba(255, 255, 255, 0.05); border-radius: 12px; padding: 15px; margin-bottom: 20px; border: 1px solid rgba(255, 255, 255, 0.1); display: none; }
        .categories-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
        .categories-header h3 { color: #888; font-size: 0.9em; text-transform: uppercase; }
        .categories-list { display: flex; gap: 8px; flex-wrap: wrap; }
        .category-pill { padding: 8px 16px; border-radius: 20px; background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); color: #888; cursor: pointer; transition: all 0.2s; font-size: 0.85em; display: flex; align-items: center; gap: 6px; }
        .category-pill:hover { background: rgba(255, 255, 255, 0.1); color: #fff; }
        .category-pill.active { background: rgba(0, 212, 255, 0.2); border-color: #00d4ff; color: #00d4ff; }
        .category-pill .cat-count { background: rgba(0, 0, 0, 0.3); padding: 2px 6px; border-radius: 10px; font-size: 0.8em; }
        .controls-bar { background: rgba(255, 255, 255, 0.05); border-radius: 12px; padding: 20px; margin-bottom: 20px; border: 1px solid rgba(255, 255, 255, 0.1); }
        .controls-row { display: flex; gap: 15px; flex-wrap: wrap; align-items: flex-end; }
        .control-group { display: flex; flex-direction: column; gap: 6px; }
        .control-group label { font-size: 0.8em; color: #888; text-transform: uppercase; }
        .control-group input, .control-group select { padding: 10px 14px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; background: rgba(0, 0, 0, 0.3); color: #fff; font-size: 0.95em; min-width: 150px; }
        .control-group input:focus, .control-group select:focus { outline: none; border-color: #00d4ff; }
        .search-input { flex: 1; min-width: 250px; }
        .type-pills { display: flex; gap: 8px; }
        .type-pill { padding: 8px 16px; border-radius: 20px; background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); color: #888; cursor: pointer; transition: all 0.2s; font-size: 0.85em; }
        .type-pill:hover { background: rgba(255, 255, 255, 0.1); color: #fff; }
        .type-pill.active { background: rgba(0, 212, 255, 0.2); border-color: #00d4ff; color: #00d4ff; }
        .stats-bar { display: flex; justify-content: space-between; margin-bottom: 15px; padding: 0 5px; }
        .stats-info { color: #888; font-size: 0.9em; }
        .stats-info strong { color: #00d4ff; }
        .content-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .content-card { background: rgba(255, 255, 255, 0.05); border-radius: 12px; overflow: hidden; border: 1px solid rgba(255, 255, 255, 0.08); transition: all 0.3s; position: relative; }
        .content-card:hover { transform: translateY(-5px); border-color: rgba(0, 212, 255, 0.3); box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3); }
        .card-poster { width: 100%; aspect-ratio: 2/3; object-fit: cover; background: rgba(0, 0, 0, 0.3); display: block; }
        .card-poster-live { aspect-ratio: 16/9; }
        .card-poster-placeholder { width: 100%; aspect-ratio: 2/3; background: linear-gradient(135deg, rgba(0, 212, 255, 0.1) 0%, rgba(0, 0, 0, 0.3) 100%); display: flex; align-items: center; justify-content: center; font-size: 3em; color: rgba(255, 255, 255, 0.2); }
        .card-poster-placeholder.live { aspect-ratio: 16/9; }
        .card-info { padding: 12px; }
        .card-title { font-size: 0.9em; color: #fff; margin-bottom: 6px; line-height: 1.3; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
        .card-meta { display: flex; flex-wrap: wrap; gap: 6px; align-items: center; }
        .card-group { font-size: 0.75em; color: #888; background: rgba(255, 255, 255, 0.05); padding: 3px 8px; border-radius: 4px; }
        .source-badge { font-size: 0.7em; padding: 3px 8px; border-radius: 4px; font-weight: 500; }
        .source-badge[data-color="1"] { background: rgba(46, 213, 115, 0.2); color: #2ed573; }
        .source-badge[data-color="2"] { background: rgba(255, 165, 2, 0.2); color: #ffa502; }
        .source-badge[data-color="3"] { background: rgba(255, 71, 87, 0.2); color: #ff4757; }
        .source-badge[data-color="4"] { background: rgba(116, 185, 255, 0.2); color: #74b9ff; }
        .source-badge[data-color="5"] { background: rgba(162, 155, 254, 0.2); color: #a29bfe; }
        .card-date { font-size: 0.7em; color: #666; margin-top: 4px; }
        .card-categories { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 6px; }
        .card-cat-badge { font-size: 0.65em; padding: 2px 6px; border-radius: 3px; background: rgba(46, 213, 115, 0.2); color: #2ed573; }
        .add-category-btn { position: absolute; top: 10px; right: 10px; width: 36px; height: 36px; border-radius: 50%; background: rgba(0, 0, 0, 0.6); border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.2em; transition: all 0.2s; color: rgba(255, 255, 255, 0.7); }
        .add-category-btn:hover { transform: scale(1.1); background: rgba(0, 0, 0, 0.8); color: #00d4ff; }
        .add-category-btn.has-categories { color: #2ed573; }
        .category-dropdown { position: absolute; top: 50px; right: 10px; background: rgba(20, 20, 40, 0.98); border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 8px; min-width: 200px; z-index: 100; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5); display: none; }
        .category-dropdown.show { display: block; }
        .category-dropdown-item { padding: 10px 14px; display: flex; align-items: center; gap: 8px; cursor: pointer; transition: background 0.2s; border-bottom: 1px solid rgba(255, 255, 255, 0.05); }
        .category-dropdown-item:last-child { border-bottom: none; }
        .category-dropdown-item:hover { background: rgba(255, 255, 255, 0.1); }
        .category-dropdown-item.in-category { color: #2ed573; }
        .category-dropdown-item .cat-check { width: 18px; text-align: center; }
        .new-badge { position: absolute; top: 10px; left: 10px; background: linear-gradient(135deg, #2ed573, #1abc9c); color: #000; font-size: 0.7em; font-weight: 600; padding: 4px 10px; border-radius: 4px; text-transform: uppercase; }
        .pagination { display: flex; justify-content: center; align-items: center; gap: 10px; margin-top: 30px; flex-wrap: wrap; }
        .pagination button { padding: 10px 20px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; color: #fff; cursor: pointer; transition: all 0.2s; }
        .pagination button:disabled { opacity: 0.4; cursor: not-allowed; }
        .pagination button:not(:disabled):hover { background: rgba(0, 212, 255, 0.2); border-color: #00d4ff; }
        .pagination-info { color: #888; font-size: 0.9em; }
        .empty-state { text-align: center; padding: 60px 20px; color: #666; }
        .empty-state-icon { font-size: 4em; margin-bottom: 20px; opacity: 0.3; }
        .empty-state h3 { color: #888; margin-bottom: 10px; }
        .loading { text-align: center; padding: 60px 20px; color: #888; }
        .loading-spinner { display: inline-block; width: 40px; height: 40px; border: 3px solid rgba(0, 212, 255, 0.1); border-radius: 50%; border-top-color: #00d4ff; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.8); display: none; align-items: center; justify-content: center; z-index: 1000; padding: 20px; }
        .modal-overlay.show { display: flex; }
        .modal { background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 16px; max-width: 600px; width: 100%; max-height: 90vh; overflow-y: auto; }
        .modal-header { padding: 20px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); display: flex; justify-content: space-between; align-items: center; }
        .modal-header h2 { color: #00d4ff; font-size: 1.3em; }
        .modal-close { background: none; border: none; color: #888; font-size: 1.5em; cursor: pointer; }
        .modal-close:hover { color: #fff; }
        .modal-body { padding: 20px; }
        .modal-footer { padding: 20px; border-top: 1px solid rgba(255, 255, 255, 0.1); display: flex; justify-content: flex-end; gap: 10px; }
        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; margin-bottom: 8px; color: #888; font-size: 0.9em; }
        .form-group input[type="text"], .form-group select { width: 100%; padding: 12px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; background: rgba(0, 0, 0, 0.3); color: #fff; font-size: 1em; }
        .form-row { display: flex; gap: 15px; }
        .form-row .form-group { flex: 1; }
        .icon-picker { display: flex; flex-wrap: wrap; gap: 8px; }
        .icon-option { width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; cursor: pointer; font-size: 1.3em; }
        .icon-option:hover { background: rgba(255, 255, 255, 0.1); }
        .icon-option.selected { background: rgba(0, 212, 255, 0.2); border-color: #00d4ff; }
        .mode-toggle { display: flex; gap: 10px; }
        .mode-option { flex: 1; padding: 15px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; cursor: pointer; text-align: center; }
        .mode-option:hover { background: rgba(255, 255, 255, 0.05); }
        .mode-option.selected { background: rgba(0, 212, 255, 0.15); border-color: #00d4ff; }
        .mode-option h4 { color: #fff; margin-bottom: 5px; }
        .mode-option p { font-size: 0.8em; color: #888; }
        .content-types-grid { display: flex; gap: 15px; }
        .content-type-checkbox { flex: 1; padding: 12px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; cursor: pointer; text-align: center; }
        .content-type-checkbox.selected { background: rgba(0, 212, 255, 0.15); border-color: #00d4ff; }
        .content-type-checkbox input { display: none; }
        .patterns-section { display: none; }
        .patterns-section.show { display: block; }
        .pattern-row { display: flex; gap: 10px; margin-bottom: 10px; align-items: center; }
        .pattern-row select { width: 140px; padding: 10px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; background: rgba(0, 0, 0, 0.3); color: #fff; }
        .pattern-row input { flex: 1; padding: 10px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; background: rgba(0, 0, 0, 0.3); color: #fff; }
        .pattern-row button { padding: 8px 12px; border: none; border-radius: 6px; cursor: pointer; background: rgba(255, 71, 87, 0.2); color: #ff4757; }
        .add-pattern-btn { padding: 8px 16px; border: 1px dashed rgba(255, 255, 255, 0.2); border-radius: 6px; background: transparent; color: #888; cursor: pointer; width: 100%; margin-top: 10px; }
        .add-pattern-btn:hover { border-color: #00d4ff; color: #00d4ff; }
        .pattern-logic { margin-top: 15px; display: flex; gap: 10px; align-items: center; }
        .pattern-logic label { color: #888; }
        .checkbox-option { display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 10px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; }
        .checkbox-option input[type="checkbox"] { width: 18px; height: 18px; }
        .categories-manage-list { margin-top: 15px; }
        .category-manage-item { display: flex; justify-content: space-between; align-items: center; padding: 12px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; margin-bottom: 8px; background: rgba(0, 0, 0, 0.2); }
        .category-manage-info { display: flex; align-items: center; gap: 10px; }
        .category-manage-info .icon { font-size: 1.3em; }
        .category-manage-info .name { font-weight: 500; }
        .category-manage-info .meta { font-size: 0.8em; color: #888; }
        .category-manage-actions { display: flex; gap: 8px; }
        .toast { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%) translateY(100px); padding: 12px 24px; border-radius: 8px; font-size: 0.95em; z-index: 10000; opacity: 0; transition: all 0.3s ease; }
        .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
        .toast-success { background: linear-gradient(135deg, #2ed573, #1abc9c); color: #000; font-weight: 500; }
        .toast-info { background: rgba(0, 212, 255, 0.9); color: #000; font-weight: 500; }
        .toast-error { background: rgba(255, 71, 87, 0.9); color: #fff; font-weight: 500; }
        /* Grouped items (category view) */
        .sources-badge { display: inline-flex; align-items: center; gap: 4px; font-size: 0.7em; padding: 3px 8px; border-radius: 4px; background: rgba(0, 212, 255, 0.15); color: #00d4ff; cursor: pointer; margin-left: 4px; }
        .sources-toggle { display: flex; align-items: center; justify-content: center; padding: 6px; cursor: pointer; border-top: 1px solid rgba(255, 255, 255, 0.05); color: #888; font-size: 0.8em; transition: all 0.2s; user-select: none; }
        .sources-toggle:hover { background: rgba(255, 255, 255, 0.05); color: #00d4ff; }
        .sources-toggle .arrow { display: inline-block; transition: transform 0.2s; margin-right: 4px; }
        .sources-toggle.expanded .arrow { transform: rotate(180deg); }
        .sources-list { display: none; border-top: 1px solid rgba(255, 255, 255, 0.05); background: rgba(0, 0, 0, 0.2); }
        .sources-list.show { display: block; }
        .source-row { display: flex; flex-direction: column; gap: 4px; padding: 8px 12px; border-bottom: 1px solid rgba(255, 255, 255, 0.03); font-size: 0.8em; }
        .source-row:last-child { border-bottom: none; }
        .source-row .source-row-name { color: #ccc; word-break: break-word; line-height: 1.3; }
        .source-row .source-row-meta { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }
        .source-row .source-row-group { color: #888; font-size: 0.9em; background: rgba(255, 255, 255, 0.05); padding: 2px 6px; border-radius: 3px; }
        .source-row .source-row-actions { display: flex; gap: 4px; margin-left: auto; }
        .source-row .source-row-cat-btn { width: 24px; height: 24px; border-radius: 50%; background: rgba(0, 0, 0, 0.4); border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 0.9em; color: rgba(255, 255, 255, 0.5); transition: all 0.2s; }
        .source-row .source-row-cat-btn:hover { color: #00d4ff; background: rgba(0, 0, 0, 0.6); }
        .source-row .source-row-cat-btn.has-categories { color: #2ed573; }
        /* Cart button styles */
        .add-cart-btn { position: absolute; top: 10px; right: 52px; width: 36px; height: 36px; border-radius: 50%; background: rgba(0, 0, 0, 0.6); border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.1em; transition: all 0.2s; color: rgba(255, 255, 255, 0.7); }
        .add-cart-btn:hover { transform: scale(1.1); background: rgba(0, 0, 0, 0.8); color: #2ed573; }
        .cart-link { position: relative; display: inline-flex; align-items: center; gap: 6px; }
        .cart-badge { position: absolute; top: -5px; right: -8px; background: #ff4757; color: #fff; font-size: 0.65em; font-weight: 700; min-width: 18px; height: 18px; border-radius: 9px; display: flex; align-items: center; justify-content: center; padding: 0 4px; }
        .source-row .source-row-cart-btn { width: 24px; height: 24px; border-radius: 50%; background: rgba(0, 0, 0, 0.4); border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 0.85em; color: rgba(255, 255, 255, 0.5); transition: all 0.2s; }
        .source-row .source-row-cart-btn:hover { color: #2ed573; background: rgba(0, 0, 0, 0.6); }
        /* Episode selector modal */
        .episode-list { max-height: 400px; overflow-y: auto; }
        .season-group { margin-bottom: 15px; }
        .season-header { display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; margin-bottom: 8px; cursor: pointer; }
        .season-header h4 { color: #00d4ff; font-size: 0.95em; }
        .season-header button { padding: 4px 12px; border: 1px solid rgba(0, 212, 255, 0.3); border-radius: 6px; background: transparent; color: #00d4ff; cursor: pointer; font-size: 0.8em; }
        .season-header button:hover { background: rgba(0, 212, 255, 0.15); }
        .episode-row { display: flex; align-items: center; gap: 10px; padding: 8px 12px; border-bottom: 1px solid rgba(255, 255, 255, 0.05); font-size: 0.9em; }
        .episode-row:hover { background: rgba(255, 255, 255, 0.03); }
        .episode-row input[type="checkbox"] { width: 18px; height: 18px; flex-shrink: 0; }
        .episode-row .ep-num { color: #888; min-width: 40px; }
        .episode-row .ep-title { flex: 1; }
        .episode-row .ep-ext { color: #666; font-size: 0.85em; }
        .episode-actions { display: flex; gap: 10px; margin-bottom: 15px; }
        .episode-source-selector { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; padding: 10px 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; }
        .episode-source-selector label { color: #888; font-size: 0.9em; white-space: nowrap; }
        .episode-source-selector select { flex: 1; padding: 6px 10px; border-radius: 6px; border: 1px solid rgba(255, 255, 255, 0.1); background: rgba(0, 0, 0, 0.3); color: #e0e0e0; font-size: 0.9em; }
        .episode-source-selector select:focus { border-color: #00d4ff; outline: none; }
        @media (max-width: 768px) { .controls-row { flex-direction: column; } .control-group { width: 100%; } .content-grid { grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 12px; } .form-row { flex-direction: column; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div style="display: flex; align-items: center; gap: 12px;">
                <h1>Browse Content</h1>
                <span id="version-badge" style="display: none; font-size: 0.65em; padding: 3px 10px; border-radius: 12px; background: rgba(255,255,255,0.08); color: #888; cursor: default;"></span>
            </div>
            <div class="header-nav">
                <a href="/cart" class="btn btn-secondary cart-link">üõí Cart<span class="cart-badge" id="cart-badge" style="display:none">0</span></a>
                <a href="/" class="btn btn-secondary">Settings</a>
            </div>
        </div>
        <div class="main-tabs">
            <div class="main-tab active" data-view="all" onclick="switchView('all')">All Content</div>
            <div class="main-tab" data-view="categories" onclick="switchView('categories')">My Categories</div>
        </div>
        <div class="categories-section" id="categories-section">
            <div class="categories-header">
                <h3>Select a Category</h3>
                <button class="btn btn-primary btn-small" onclick="openCategoryModal()">+ New Category</button>
            </div>
            <div class="categories-list" id="categories-list"></div>
            <div style="margin-top: 15px;"><button class="btn btn-secondary btn-small" onclick="openManageCategoriesModal()">Manage Categories</button></div>
        </div>
        <div class="controls-bar" id="controls-bar">
            <div class="controls-row">
                <div class="control-group search-input">
                    <label>Search</label>
                    <div style="display: flex; gap: 8px;">
                        <input type="text" id="search-input" placeholder="Search films, series, channels..." onkeypress="if(event.key==='Enter')applyFilters()">
                        <button class="btn btn-primary" onclick="currentPage=1;applyFilters()" style="white-space: nowrap;">üîç Search</button>
                    </div>
                </div>
                <div class="control-group">
                    <label>Content Type</label>
                    <div class="type-pills">
                        <div class="type-pill" data-type="vod" onclick="setContentType('vod')">Films</div>
                        <div class="type-pill" data-type="series" onclick="setContentType('series')">Series</div>
                        <div class="type-pill active" data-type="live" onclick="setContentType('live')">Channels</div>
                    </div>
                </div>
                <div class="control-group">
                    <label>Source</label>
                    <select id="source-filter"><option value="">All Sources</option></select>
                </div>
                <div class="control-group">
                    <label>Group</label>
                    <select id="group-filter"><option value="">All Groups</option></select>
                </div>
                <div class="control-group">
                    <label>&nbsp;</label>
                    <label class="checkbox-option" style="padding: 10px 14px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="use-source-filters-browse" style="width: 18px; height: 18px;">
                        <span style="white-space: nowrap;">Apply source filter rules</span>
                    </label>
                </div>
            </div>
        </div>
        <div class="stats-bar"><div class="stats-info">Showing <strong id="showing-count">0</strong> of <strong id="total-count">0</strong> items</div></div>
        <div id="loading-state" class="loading" style="display: none;"><div class="loading-spinner"></div><p>Loading content...</p></div>
        <div id="empty-state" class="empty-state" style="display: none;"><div class="empty-state-icon">No results</div><h3>No content found</h3><p>Try adjusting your filters or search terms</p></div>
        <div class="content-grid" id="content-grid"></div>
        <div class="pagination" id="pagination" style="display: none;">
            <button onclick="goToPage(1)" id="first-page-btn">First</button>
            <button onclick="goToPage(currentPage - 1)" id="prev-page-btn">Previous</button>
            <span class="pagination-info">Page <strong id="current-page">1</strong> of <strong id="total-pages">1</strong></span>
            <button onclick="goToPage(currentPage + 1)" id="next-page-btn">Next</button>
            <button onclick="goToPage(totalPages)" id="last-page-btn">Last</button>
        </div>
    </div>

    <!-- Category Modal -->
    <div class="modal-overlay" id="category-modal">
        <div class="modal">
            <div class="modal-header">
                <h2 id="category-modal-title">Create Category</h2>
                <button class="modal-close" onclick="closeCategoryModal()">&times;</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="category-edit-id">
                <div class="form-row">
                    <div class="form-group">
                        <label>Category Name</label>
                        <input type="text" id="category-name" placeholder="My Category">
                    </div>
                    <div class="form-group">
                        <label>Icon</label>
                        <div class="icon-picker" id="icon-picker">
                            <div class="icon-option selected" data-icon="folder">üìÅ</div>
                            <div class="icon-option" data-icon="heart">‚ù§Ô∏è</div>
                            <div class="icon-option" data-icon="star">‚≠ê</div>
                            <div class="icon-option" data-icon="film">üé¨</div>
                            <div class="icon-option" data-icon="tv">üì∫</div>
                            <div class="icon-option" data-icon="game">üéÆ</div>
                            <div class="icon-option" data-icon="music">üéµ</div>
                            <div class="icon-option" data-icon="sport">üèÄ</div>
                            <div class="icon-option" data-icon="fire">üî•</div>
                            <div class="icon-option" data-icon="bookmark">üîñ</div>
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <label>Mode</label>
                    <div class="mode-toggle">
                        <div class="mode-option selected" data-mode="manual" onclick="selectMode('manual')">
                            <h4>Manual</h4>
                            <p>Add items yourself</p>
                        </div>
                        <div class="mode-option" data-mode="automatic" onclick="selectMode('automatic')">
                            <h4>Automatic</h4>
                            <p>Use search patterns</p>
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <label>Content Types</label>
                    <div class="content-types-grid">
                        <div class="content-type-checkbox selected" data-type="live" onclick="toggleContentType(this)">
                            Channels
                        </div>
                        <div class="content-type-checkbox selected" data-type="vod" onclick="toggleContentType(this)">
                            Films
                        </div>
                        <div class="content-type-checkbox selected" data-type="series" onclick="toggleContentType(this)">
                            Series
                        </div>
                    </div>
                </div>
                <div class="patterns-section" id="patterns-section">
                    <div class="form-group">
                        <label>Recently Added Filter</label>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                <input type="checkbox" id="use-recently-added" onchange="toggleRecentlyAdded()" style="width: 18px; height: 18px;">
                                <span>Only include items added within</span>
                            </label>
                            <select id="recently-added-days" disabled style="padding: 8px 12px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; background: rgba(0, 0, 0, 0.3); color: #fff;">
                                <option value="7">Last 7 days</option>
                                <option value="14">Last 14 days</option>
                                <option value="30">Last 30 days</option>
                                <option value="60">Last 60 days</option>
                                <option value="90">Last 90 days</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Search Patterns (matches item name) - Optional</label>
                        <div id="patterns-container">
                            <div class="pattern-row">
                                <select>
                                    <option value="contains">Contains</option>
                                    <option value="not_contains">Does not contain</option>
                                    <option value="starts_with">Starts with</option>
                                    <option value="ends_with">Ends with</option>
                                    <option value="exact">Exact match</option>
                                    <option value="regex">Regex</option>
                                </select>
                                <input type="text" placeholder="e.g. 4K, Sport, Movie">
                                <button onclick="removePattern(this)">X</button>
                            </div>
                        </div>
                        <button class="add-pattern-btn" onclick="addPattern()">+ Add Pattern</button>
                    </div>
                    <div class="pattern-logic">
                        <label>Match logic:</label>
                        <select id="pattern-logic">
                            <option value="or">Match ANY pattern (OR)</option>
                            <option value="and">Match ALL patterns (AND)</option>
                        </select>
                    </div>
                    <div class="form-group" style="margin-top: 15px;">
                        <label class="checkbox-option">
                            <input type="checkbox" id="use-source-filters">
                            <span>Apply source filter rules</span>
                        </label>
                    </div>
                    <div class="form-group" style="margin-top: 10px;">
                        <label class="checkbox-option">
                            <input type="checkbox" id="notify-telegram">
                            <span>üì± Send Telegram notification when new items are found</span>
                        </label>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeCategoryModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveCategory()">Save Category</button>
            </div>
        </div>
    </div>
    <!-- Manage Categories Modal -->
    <div class="modal-overlay" id="manage-modal">
        <div class="modal">
            <div class="modal-header">
                <h2>Manage Categories</h2>
                <button class="modal-close" onclick="closeManageCategoriesModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="categories-manage-list" id="categories-manage-list"></div>
                <button class="btn btn-primary" style="margin-top: 15px; width: 100%;" onclick="closeManageCategoriesModal(); openCategoryModal();">+ Create New Category</button>
            </div>
        </div>
    </div>
    <!-- Episode Selector Modal -->
    <div class="modal-overlay" id="episode-modal">
        <div class="modal" style="max-width: 700px;">
            <div class="modal-header">
                <h2 id="episode-modal-title">Select Episodes</h2>
                <button class="modal-close" onclick="closeEpisodeModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="episode-source-selector" id="episode-source-selector" style="display:none">
                    <label>Source:</label>
                    <select id="episode-source-select" onchange="onEpisodeSourceChange()"></select>
                </div>
                <div class="episode-actions">
                    <button class="btn btn-primary btn-small" onclick="addAllEpisodesToCart()">Add All Episodes</button>
                    <button class="btn btn-secondary btn-small" onclick="addSelectedEpisodesToCart()">Add Selected</button>
                </div>
                <div class="episode-list" id="episode-list">
                    <div class="loading"><div class="loading-spinner"></div><p>Loading episodes...</p></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeEpisodeModal()">Close</button>
            </div>
        </div>
    </div>

    <script>
        let currentView = 'all';
        let contentType = 'live';
        let currentPage = 1;
        let totalPages = 1;
        let searchTimeout = null;
        let sources = [];
        let categories = [];
        let selectedCategoryId = null;
        let currentFetchController = null; // AbortController for cancelling in-flight requests

        const iconMap = {
            'folder': 'üìÅ', 'heart': '‚ù§Ô∏è', 'star': '‚≠ê', 'film': 'üé¨', 'tv': 'üì∫',
            'game': 'üéÆ', 'music': 'üéµ', 'sport': 'üèÄ', 'fire': 'üî•', 'bookmark': 'üîñ'
        };

        document.addEventListener('DOMContentLoaded', function() {
            loadSources();
            loadCategories();
            // Show initial state without auto-loading results
            document.getElementById('loading-state').style.display = 'none';
            document.getElementById('empty-state').innerHTML = '<p>Use the filters above and click <strong>Search</strong> to browse content.</p>';
            document.getElementById('empty-state').style.display = 'block';
            document.querySelectorAll('.icon-option').forEach(opt => {
                opt.addEventListener('click', function() {
                    document.querySelectorAll('.icon-option').forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                });
            });
            document.addEventListener('click', function(e) {
                document.querySelectorAll('.category-dropdown.show').forEach(d => d.classList.remove('show'));
            });
        });

        async function loadSources() {
            try {
                const response = await fetch('/api/sources');
                const data = await response.json();
                sources = data.sources || [];
                const sourceFilter = document.getElementById('source-filter');
                sourceFilter.innerHTML = '<option value="">All Sources</option>';
                sources.forEach((source, index) => {
                    const option = document.createElement('option');
                    option.value = source.id;
                    option.textContent = source.name;
                    sourceFilter.appendChild(option);
                });
            } catch (error) { console.error('Error loading sources:', error); }
        }

        async function loadCategories() {
            try {
                const response = await fetch('/api/categories');
                const data = await response.json();
                categories = data.categories || [];
                renderCategoriesList();
            } catch (error) { console.error('Error loading categories:', error); }
        }

        function renderCategoriesList() {
            const container = document.getElementById('categories-list');
            container.innerHTML = categories.map(cat => {
                const count = cat.mode === 'automatic' ? (cat.cached_items || []).length : (cat.items || []).length;
                const icon = iconMap[cat.icon] || cat.icon || 'üìÅ';
                const isActive = selectedCategoryId === cat.id ? 'active' : '';
                const modeIndicator = cat.mode === 'automatic' ? ' ü§ñ' : '';
                return '<div class="category-pill ' + isActive + '" onclick="selectCategory(\'' + cat.id + '\')">' +
                    '<span>' + icon + '</span><span>' + cat.name + modeIndicator + '</span>' +
                    '<span class="cat-count">' + count + '</span></div>';
            }).join('');
        }

        function selectCategory(categoryId) {
            if (selectedCategoryId === categoryId) {
                selectedCategoryId = null;
            } else {
                selectedCategoryId = categoryId;
                // Auto-select first content type from the category if current one is not included
                const cat = categories.find(c => c.id === categoryId);
                if (cat && cat.content_types && cat.content_types.length > 0) {
                    if (!cat.content_types.includes(contentType)) {
                        setContentType(cat.content_types[0]);
                    }
                }
            }
            renderCategoriesList();
            currentPage = 1;
            applyFilters();
        }

        function switchView(view) {
            currentView = view;
            document.querySelectorAll('.main-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.view === view);
            });
            const categoriesSection = document.getElementById('categories-section');
            const controlsBar = document.getElementById('controls-bar');
            if (view === 'categories') {
                categoriesSection.style.display = 'block';
                controlsBar.style.display = 'none';
            } else {
                categoriesSection.style.display = 'none';
                controlsBar.style.display = 'block';
                selectedCategoryId = null;
            }
            renderCategoriesList();
            currentPage = 1;
            applyFilters();
        }

        function setContentType(type) {
            contentType = type;
            document.querySelectorAll('.type-pill').forEach(pill => {
                pill.classList.toggle('active', pill.dataset.type === type);
            });
            currentPage = 1;
            // Don't auto-search - user will click Search button
        }

        async function loadGroups() {
            // Groups are loaded from browse API response instead
            // This function is kept for compatibility but does nothing
            // Groups will be populated by applyFilters
        }

        function debounceSearch() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => { currentPage = 1; applyFilters(); }, 300);
        }

        async function applyFilters() {
            // Cancel any in-flight request
            if (currentFetchController) {
                currentFetchController.abort();
            }
            currentFetchController = new AbortController();
            const signal = currentFetchController.signal;

            const searchQuery = document.getElementById('search-input').value;
            const sourceId = document.getElementById('source-filter').value;
            const group = document.getElementById('group-filter').value;
            const useSourceFilters = document.getElementById('use-source-filters-browse').checked;
            const loadingState = document.getElementById('loading-state');
            const emptyState = document.getElementById('empty-state');
            const contentGrid = document.getElementById('content-grid');
            const pagination = document.getElementById('pagination');

            loadingState.style.display = 'block';
            emptyState.style.display = 'none';
            contentGrid.innerHTML = '';
            pagination.style.display = 'none';

            // If in categories view but no category selected, show prompt instead of loading
            if (currentView === 'categories' && !selectedCategoryId) {
                loadingState.style.display = 'none';
                emptyState.innerHTML = '<div class="empty-state-icon">üìÅ</div><h3>Select a category</h3><p>Click on a category above to see its content</p>';
                emptyState.style.display = 'block';
                document.getElementById('showing-count').textContent = '0';
                document.getElementById('total-count').textContent = '0';
                return;
            }

            try {
                let url = '/api/browse?type=' + contentType + '&page=' + currentPage + '&per_page=50';
                // Only apply search/source/group filters when in "all" view, not in categories view
                if (currentView === 'all') {
                    if (searchQuery) url += '&search=' + encodeURIComponent(searchQuery);
                    if (sourceId) url += '&source=' + sourceId;
                    if (group) url += '&group=' + encodeURIComponent(group);
                    if (useSourceFilters) url += '&use_source_filters=true';
                } else if (currentView === 'categories' && selectedCategoryId) {
                    url += '&category_id=' + selectedCategoryId;
                }

                const response = await fetch(url, { signal });
                const data = await response.json();

                loadingState.style.display = 'none';
                document.getElementById('showing-count').textContent = data.items.length;
                document.getElementById('total-count').textContent = data.total;

                // Populate groups dropdown from API response
                if (data.groups && data.groups.length > 0) {
                    const groupFilter = document.getElementById('group-filter');
                    const currentValue = groupFilter.value;
                    groupFilter.innerHTML = '<option value="">All Groups</option>';
                    data.groups.forEach(g => {
                        const option = document.createElement('option');
                        option.value = g.name;
                        option.textContent = g.name + ' (' + g.count + ')';
                        groupFilter.appendChild(option);
                    });
                    if (data.groups.some(g => g.name === currentValue)) groupFilter.value = currentValue;
                }

                if (data.items.length === 0) {
                    emptyState.style.display = 'block';
                    return;
                }

                totalPages = data.total_pages;
                currentPage = data.page;
                renderContent(data.items, data.grouped);
                updatePagination();
            } catch (error) {
                // Ignore aborted requests (user clicked another category)
                if (error.name === 'AbortError') {
                    return;
                }
                console.error('Error fetching content:', error);
                loadingState.style.display = 'none';
                emptyState.style.display = 'block';
            }
        }

        function renderContent(items, grouped) {
            const grid = document.getElementById('content-grid');
            grid.innerHTML = items.map((item, idx) => {
                if (grouped && item.count > 1) {
                    return renderGroupedCard(item, idx);
                }
                // Single item (or non-grouped mode)
                const single = (grouped && item.items) ? item.items[0] : item;
                return renderSingleCard(single);
            }).join('');
        }

        function renderSingleCard(item) {
            const posterClass = contentType === 'live' ? 'card-poster-placeholder live' : 'card-poster-placeholder';
            const poster = item.icon;
            const placeholderIcon = contentType === 'live' ? 'üì°' : 'üé¨';
            const imgClass = 'card-poster' + (contentType === 'live' ? ' card-poster-live' : '');
            const posterHtml = poster
                ? '<img class="' + imgClass + '" src="' + poster + '" loading="lazy" onerror="this.style.display=\'none\';this.nextSibling.style.display=\'flex\'"><div class="' + posterClass + '" style="display:none">' + placeholderIcon + '</div>'
                : '<div class="' + posterClass + '">' + placeholderIcon + '</div>';
            const sourceIndex = sources.findIndex(s => s.id === item.source_id) + 1;
            const sourceName = item.source_name || 'Unknown';
            const isNew = item.added && isRecent(item.added, 7);
            const itemCategories = getItemCategories(item);
            const hasCats = itemCategories.length > 0;

            let catBadges = '';
            if (itemCategories.length > 0) {
                catBadges = '<div class="card-categories">' + itemCategories.slice(0, 3).map(c => '<span class="card-cat-badge">' + (iconMap[c.icon] || c.icon) + ' ' + c.name + '</span>').join('') + '</div>';
            }

            const cartBtn = (contentType === 'vod' || contentType === 'series')
                ? '<button class="add-cart-btn" data-source-id="' + escapeAttr(item.source_id) + '" data-item-id="' + escapeAttr(item.id) + '" data-content-type="' + escapeAttr(contentType) + '" data-name="' + escapeAttr(item.name) + '" data-icon="' + escapeAttr(item.icon || '') + '" data-group="' + escapeAttr(item.group || '') + '" title="Add to download cart">üõí</button>'
                : '';

            return '<div class="content-card">' +
                (isNew ? '<div class="new-badge">NEW</div>' : '') +
                cartBtn +
                '<button class="add-category-btn' + (hasCats ? ' has-categories' : '') + '" onclick="toggleCategoryDropdown(event, \'' + item.source_id + '\', \'' + item.id + '\', \'' + contentType + '\')">+</button>' +
                '<div class="category-dropdown" id="cat-dropdown-' + item.source_id + '-' + item.id + '"></div>' +
                posterHtml +
                '<div class="card-info">' +
                '<div class="card-title">' + escapeHtml(item.name) + '</div>' +
                '<div class="card-meta">' +
                '<span class="source-badge" data-color="' + (sourceIndex % 5 || 5) + '">' + escapeHtml(sourceName) + '</span>' +
                (item.group ? '<span class="card-group">' + escapeHtml(item.group) + '</span>' : '') +
                '</div>' +
                catBadges +
                (item.added ? '<div class="card-date">Added: ' + formatDate(item.added) + '</div>' : '') +
                '</div></div>';
        }

        function renderGroupedCard(group, idx) {
            const posterClass = contentType === 'live' ? 'card-poster-placeholder live' : 'card-poster-placeholder';
            const poster = group.icon;
            const placeholderIcon = contentType === 'live' ? 'üì°' : 'üé¨';
            const imgClass = 'card-poster' + (contentType === 'live' ? ' card-poster-live' : '');
            const posterHtml = poster
                ? '<img class="' + imgClass + '" src="' + poster + '" loading="lazy" onerror="this.style.display=\'none\';this.nextSibling.style.display=\'flex\'"><div class="' + posterClass + '" style="display:none">' + placeholderIcon + '</div>'
                : '<div class="' + posterClass + '">' + placeholderIcon + '</div>';

            // Collect categories from all sub-items (deduplicated)
            const allCatIds = new Set();
            const allCats = [];
            group.items.forEach(sub => {
                getItemCategories(sub).forEach(c => {
                    if (!allCatIds.has(c.id)) { allCatIds.add(c.id); allCats.push(c); }
                });
            });
            let catBadges = '';
            if (allCats.length > 0) {
                catBadges = '<div class="card-categories">' + allCats.slice(0, 3).map(c => '<span class="card-cat-badge">' + (iconMap[c.icon] || c.icon) + ' ' + c.name + '</span>').join('') + '</div>';
            }

            // Check if any sub-item is new
            const isNew = group.items.some(sub => sub.added && isRecent(sub.added, 7));

            // Build top-level cart button for grouped series cards with all sources encoded
            let groupCartBtn = '';
            if (contentType === 'series' || contentType === 'vod') {
                const allSourcesData = group.items.map(sub => ({
                    source_id: sub.source_id,
                    source_name: sub.source_name || 'Unknown',
                    item_id: sub.id,
                    name: sub.name,
                    icon: sub.icon || sub.cover || '',
                    group: sub.group || ''
                }));
                groupCartBtn = '<button class="add-cart-btn" data-source-id="' + escapeAttr(group.items[0].source_id) + '" data-item-id="' + escapeAttr(group.items[0].id) + '" data-content-type="' + escapeAttr(contentType) + '" data-name="' + escapeAttr(group.name) + '" data-icon="' + escapeAttr(group.icon || '') + '" data-group="' + escapeAttr(group.items[0].group || '') + '" data-all-sources="' + escapeAttr(JSON.stringify(allSourcesData)) + '" title="Add to download cart">üõí</button>';
            }

            // Build source rows for expand area
            const sourceRows = group.items.map(sub => {
                const si = sources.findIndex(s => s.id === sub.source_id) + 1;
                const sName = sub.source_name || 'Unknown';
                const subCats = getItemCategories(sub);
                const subHasCats = subCats.length > 0;
                return '<div class="source-row">' +
                    '<div class="source-row-name">' + escapeHtml(sub.name) + '</div>' +
                    '<div class="source-row-meta">' +
                    '<span class="source-badge" data-color="' + (si % 5 || 5) + '">' + escapeHtml(sName) + '</span>' +
                    (sub.group ? '<span class="source-row-group">' + escapeHtml(sub.group) + '</span>' : '') +
                    '<span class="source-row-actions">' +
                    ((contentType === 'vod' || contentType === 'series') ? '<button class="source-row-cart-btn add-cart-btn" data-source-id="' + escapeAttr(sub.source_id) + '" data-item-id="' + escapeAttr(sub.id) + '" data-content-type="' + escapeAttr(contentType) + '" data-name="' + escapeAttr(sub.name) + '" data-icon="' + escapeAttr(sub.icon || sub.cover || '') + '" data-group="' + escapeAttr(sub.group || '') + '" title="Add to cart">üõí</button>' : '') +
                    '<button class="source-row-cat-btn' + (subHasCats ? ' has-categories' : '') + '" onclick="toggleCategoryDropdown(event, \'' + sub.source_id + '\', \'' + sub.id + '\', \'' + contentType + '\')">+</button>' +
                    '<div class="category-dropdown" id="cat-dropdown-' + sub.source_id + '-' + sub.id + '" style="position:relative;top:0;right:0;"></div>' +
                    '</span>' +
                    '</div>' +
                    '</div>';
            }).join('');

            const groupId = 'group-' + idx;

            return '<div class="content-card">' +
                (isNew ? '<div class="new-badge">NEW</div>' : '') +
                groupCartBtn +
                posterHtml +
                '<div class="card-info">' +
                '<div class="card-title">' + escapeHtml(group.name) +
                '<span class="sources-badge">' + group.count + ' sources</span>' +
                '</div>' +
                catBadges +
                '</div>' +
                '<div class="sources-toggle" onclick="toggleSourcesList(this, \'' + groupId + '\')">' +
                '<span class="arrow">‚ñº</span> Show ' + group.count + ' sources' +
                '</div>' +
                '<div class="sources-list" id="' + groupId + '">' +
                sourceRows +
                '</div>' +
                '</div>';
        }

        function toggleSourcesList(toggleEl, groupId) {
            const list = document.getElementById(groupId);
            const isOpen = list.classList.contains('show');
            list.classList.toggle('show');
            toggleEl.classList.toggle('expanded');
            toggleEl.querySelector('.arrow').textContent = isOpen ? '‚ñº' : '‚ñ≤';
            const label = isOpen ? 'Show' : 'Hide';
            const count = list.querySelectorAll('.source-row').length;
            toggleEl.innerHTML = '<span class="arrow">' + (isOpen ? '‚ñº' : '‚ñ≤') + '</span> ' + label + ' ' + count + ' sources';
        }

        function getItemCategories(item) {
            return categories.filter(cat => {
                if (cat.mode === 'manual') {
                    return (cat.items || []).some(i => i.source_id === item.source_id && String(i.id) === String(item.id) && i.content_type === contentType);
                } else {
                    return (cat.cached_items || []).some(i => i.source_id === item.source_id && String(i.id) === String(item.id) && i.content_type === contentType);
                }
            });
        }

        function toggleCategoryDropdown(event, sourceId, itemId, cType) {
            event.stopPropagation();
            document.querySelectorAll('.category-dropdown.show').forEach(d => d.classList.remove('show'));
            const dropdown = document.getElementById('cat-dropdown-' + sourceId + '-' + itemId);
            const itemCats = categories.filter(cat => {
                const items = cat.mode === 'manual' ? cat.items : cat.cached_items;
                return (items || []).some(i => i.source_id === sourceId && String(i.id) === String(itemId) && i.content_type === cType);
            });

            dropdown.innerHTML = categories.filter(c => c.mode === 'manual').map(cat => {
                const isIn = itemCats.some(ic => ic.id === cat.id);
                const icon = iconMap[cat.icon] || cat.icon || 'üìÅ';
                return '<div class="category-dropdown-item' + (isIn ? ' in-category' : '') + '" onclick="toggleItemInCategory(event, \'' + cat.id + '\', \'' + sourceId + '\', \'' + itemId + '\', \'' + cType + '\')">' +
                    '<span class="cat-check">' + (isIn ? '‚úì' : '') + '</span>' +
                    '<span>' + icon + ' ' + escapeHtml(cat.name) + '</span></div>';
            }).join('') || '<div class="category-dropdown-item" style="color:#666">No manual categories</div>';

            dropdown.classList.add('show');
        }

        async function toggleItemInCategory(event, categoryId, sourceId, itemId, cType) {
            event.stopPropagation();
            const cat = categories.find(c => c.id === categoryId);
            const isIn = (cat.items || []).some(i => i.source_id === sourceId && String(i.id) === String(itemId) && i.content_type === cType);

            try {
                if (isIn) {
                    await fetch('/api/categories/' + categoryId + '/items/' + cType + '/' + sourceId + '/' + itemId, { method: 'DELETE' });
                    showToast('Removed from ' + cat.name, 'info');
                } else {
                    await fetch('/api/categories/' + categoryId + '/items', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ source_id: sourceId, id: String(itemId), content_type: cType })
                    });
                    showToast('Added to ' + cat.name, 'success');
                }
                await loadCategories();
                // Update the + button style and dropdown for this item without reloading results
                updateItemCategoryUI(sourceId, itemId, cType);
            } catch (error) { 
                console.error('Error toggling item in category:', error);
                showToast('Error updating category', 'error');
            }
        }

        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = 'toast toast-' + type;
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.classList.add('show'), 10);
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, 2000);
        }

        function updateItemCategoryUI(sourceId, itemId, cType) {
            // Check if item is in any category
            const hasCats = categories.some(cat => {
                const items = cat.mode === 'manual' ? cat.items : cat.cached_items;
                return (items || []).some(i => i.source_id === sourceId && String(i.id) === String(itemId) && i.content_type === cType);
            });
            
            // Update the + button style
            const card = document.querySelector('.content-card button[onclick*="' + sourceId + '"][onclick*="' + itemId + '"]');
            if (card) {
                card.classList.toggle('has-categories', hasCats);
            }
            
            // Refresh the dropdown content
            const dropdown = document.getElementById('cat-dropdown-' + sourceId + '-' + itemId);
            if (dropdown && dropdown.classList.contains('show')) {
                const itemCats = categories.filter(cat => {
                    const items = cat.mode === 'manual' ? cat.items : cat.cached_items;
                    return (items || []).some(i => i.source_id === sourceId && i.item_id === String(itemId) && i.content_type === cType);
                });
                dropdown.innerHTML = categories.filter(c => c.mode === 'manual').map(cat => {
                    const isIn = itemCats.some(ic => ic.id === cat.id);
                    const icon = iconMap[cat.icon] || cat.icon || 'üìÅ';
                    return '<div class="category-dropdown-item' + (isIn ? ' in-category' : '') + '" onclick="toggleItemInCategory(event, \'' + cat.id + '\', \'' + sourceId + '\', \'' + itemId + '\', \'' + cType + '\')">' +
                        '<span class="cat-check">' + (isIn ? '‚úì' : '') + '</span>' +
                        '<span>' + icon + ' ' + escapeHtml(cat.name) + '</span></div>';
                }).join('') || '<div class="category-dropdown-item" style="color:#666">No manual categories</div>';
            }
        }

        function openCategoryModal(categoryId = null) {
            const modal = document.getElementById('category-modal');
            const title = document.getElementById('category-modal-title');
            document.getElementById('category-edit-id').value = categoryId || '';
            title.textContent = categoryId ? 'Edit Category' : 'Create Category';

            if (categoryId) {
                const cat = categories.find(c => c.id === categoryId);
                if (cat) {
                    document.getElementById('category-name').value = cat.name;
                    document.querySelectorAll('.icon-option').forEach(o => {
                        o.classList.toggle('selected', o.dataset.icon === cat.icon);
                    });
                    selectMode(cat.mode);
                    document.querySelectorAll('.content-type-checkbox').forEach(cb => {
                        const isSelected = (cat.content_types || []).includes(cb.dataset.type);
                        cb.classList.toggle('selected', isSelected);
                    });
                    document.getElementById('pattern-logic').value = cat.pattern_logic || 'or';
                    document.getElementById('use-source-filters').checked = cat.use_source_filters || false;
                    document.getElementById('notify-telegram').checked = cat.notify_telegram || false;
                    // Handle recently added filter
                    const recentlyAddedDays = cat.recently_added_days || 0;
                    document.getElementById('use-recently-added').checked = recentlyAddedDays > 0;
                    document.getElementById('recently-added-days').value = recentlyAddedDays > 0 ? recentlyAddedDays : '7';
                    document.getElementById('recently-added-days').disabled = recentlyAddedDays === 0;
                    renderPatterns(cat.patterns || []);
                }
            } else {
                document.getElementById('category-name').value = '';
                document.querySelectorAll('.icon-option').forEach((o, i) => o.classList.toggle('selected', i === 0));
                selectMode('manual');
                document.querySelectorAll('.content-type-checkbox').forEach(cb => {
                    cb.classList.add('selected');
                });
                document.getElementById('pattern-logic').value = 'or';
                document.getElementById('use-source-filters').checked = false;
                document.getElementById('notify-telegram').checked = false;
                document.getElementById('use-recently-added').checked = false;
                document.getElementById('recently-added-days').value = '7';
                document.getElementById('recently-added-days').disabled = true;
                renderPatterns([]);
            }
            modal.classList.add('show');
        }

        function closeCategoryModal() { document.getElementById('category-modal').classList.remove('show'); }

        function selectMode(mode) {
            document.querySelectorAll('.mode-option').forEach(o => o.classList.toggle('selected', o.dataset.mode === mode));
            document.getElementById('patterns-section').classList.toggle('show', mode === 'automatic');
        }

        function toggleContentType(el) {
            el.classList.toggle('selected');
        }

        function toggleRecentlyAdded() {
            const checkbox = document.getElementById('use-recently-added');
            const select = document.getElementById('recently-added-days');
            select.disabled = !checkbox.checked;
        }

        function renderPatterns(patterns) {
            const container = document.getElementById('patterns-container');
            if (patterns.length === 0) {
                container.innerHTML = '<div class="pattern-row"><select><option value="contains">Contains</option><option value="not_contains">Does not contain</option><option value="starts_with">Starts with</option><option value="ends_with">Ends with</option><option value="exact">Exact match</option><option value="regex">Regex</option></select><input type="text" placeholder="e.g. 4K, Sport, Movie"><button onclick="removePattern(this)">X</button></div>';
            } else {
                container.innerHTML = patterns.map(p => '<div class="pattern-row"><select>' + ['contains', 'not_contains', 'starts_with', 'ends_with', 'exact', 'regex'].map(m => '<option value="' + m + '"' + (p.match === m ? ' selected' : '') + '>' + {'contains':'Contains','not_contains':'Does not contain','starts_with':'Starts with','ends_with':'Ends with','exact':'Exact match','regex':'Regex'}[m] + '</option>').join('') + '</select><input type="text" value="' + escapeHtml(p.value) + '"><button onclick="removePattern(this)">X</button></div>').join('');
            }
        }

        function addPattern() {
            const container = document.getElementById('patterns-container');
            const newRow = document.createElement('div');
            newRow.className = 'pattern-row';
            newRow.innerHTML = '<select><option value="contains">Contains</option><option value="not_contains">Does not contain</option><option value="starts_with">Starts with</option><option value="ends_with">Ends with</option><option value="exact">Exact match</option><option value="regex">Regex</option></select><input type="text" placeholder="e.g. 4K, Sport, Movie"><button onclick="removePattern(this)">X</button>';
            container.appendChild(newRow);
        }

        function removePattern(btn) {
            const container = document.getElementById('patterns-container');
            if (container.children.length > 1) btn.parentElement.remove();
        }

        async function saveCategory() {
            const editId = document.getElementById('category-edit-id').value;
            const name = document.getElementById('category-name').value.trim();
            const icon = document.querySelector('.icon-option.selected')?.dataset.icon || 'folder';
            const mode = document.querySelector('.mode-option.selected')?.dataset.mode || 'manual';
            const contentTypes = Array.from(document.querySelectorAll('.content-type-checkbox.selected')).map(cb => cb.dataset.type);
            const patternLogic = document.getElementById('pattern-logic').value;
            const useSourceFilters = document.getElementById('use-source-filters').checked;
            const notifyTelegram = document.getElementById('notify-telegram').checked;
            const useRecentlyAdded = document.getElementById('use-recently-added').checked;
            const recentlyAddedDays = useRecentlyAdded ? parseInt(document.getElementById('recently-added-days').value) : 0;
            const patterns = Array.from(document.querySelectorAll('#patterns-container .pattern-row')).map(row => ({
                match: row.querySelector('select').value,
                value: row.querySelector('input').value,
                case_sensitive: false
            })).filter(p => p.value.trim());

            const data = { name, icon, mode, content_types: contentTypes, patterns, pattern_logic: patternLogic, use_source_filters: useSourceFilters, notify_telegram: notifyTelegram, recently_added_days: recentlyAddedDays };

            try {
                const url = editId ? '/api/categories/' + editId : '/api/categories';
                const method = editId ? 'PUT' : 'POST';
                const response = await fetch(url, { method, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) });
                closeCategoryModal();
                await loadCategories();
                if (mode === 'automatic') await fetch('/api/categories/refresh', { method: 'POST' });
                await loadCategories();
            } catch (error) { console.error('Error saving category:', error); alert('Failed to save category'); }
        }

        function openManageCategoriesModal() {
            const container = document.getElementById('categories-manage-list');
            container.innerHTML = categories.map(cat => {
                const icon = iconMap[cat.icon] || cat.icon || 'üìÅ';
                const count = cat.mode === 'automatic' ? (cat.cached_items || []).length : (cat.items || []).length;
                return '<div class="category-manage-item"><div class="category-manage-info"><span class="icon">' + icon + '</span><div><div class="name">' + escapeHtml(cat.name) + '</div><div class="meta">' + cat.mode + ' - ' + count + ' items</div></div></div><div class="category-manage-actions"><button class="btn btn-small btn-secondary" onclick="closeManageCategoriesModal(); openCategoryModal(\'' + cat.id + '\')">Edit</button><button class="btn btn-small btn-danger" onclick="deleteCategory(\'' + cat.id + '\')">Delete</button></div></div>';
            }).join('') || '<p style="color:#888">No categories yet</p>';
            document.getElementById('manage-modal').classList.add('show');
        }

        function closeManageCategoriesModal() { document.getElementById('manage-modal').classList.remove('show'); }

        async function deleteCategory(categoryId) {
            try {
                await fetch('/api/categories/' + categoryId, { method: 'DELETE' });
                await loadCategories();
                if (selectedCategoryId === categoryId) { selectedCategoryId = null; applyFilters(); }
                openManageCategoriesModal();
            } catch (error) { console.error('Error deleting category:', error); }
        }

        function updatePagination() {
            const pagination = document.getElementById('pagination');
            pagination.style.display = totalPages > 1 ? 'flex' : 'none';
            document.getElementById('current-page').textContent = currentPage;
            document.getElementById('total-pages').textContent = totalPages;
            document.getElementById('first-page-btn').disabled = currentPage === 1;
            document.getElementById('prev-page-btn').disabled = currentPage === 1;
            document.getElementById('next-page-btn').disabled = currentPage === totalPages;
            document.getElementById('last-page-btn').disabled = currentPage === totalPages;
        }

        function goToPage(page) {
            if (page < 1 || page > totalPages) return;
            currentPage = page;
            applyFilters();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function isRecent(timestamp, days) {
            if (!timestamp) return false;
            const date = new Date(timestamp * 1000);
            const now = new Date();
            const diffDays = (now - date) / (1000 * 60 * 60 * 24);
            return diffDays <= days;
        }

        function formatDate(timestamp) {
            if (!timestamp) return '';
            const date = new Date(timestamp * 1000);
            return date.toLocaleDateString();
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function jsEscape(str) {
            return String(str || '').replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '');
        }

        function escapeAttr(str) {
            return String(str || '').replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }

        loadGroups();

        // ============================================
        // DOWNLOAD CART FUNCTIONS
        // ============================================
        let _episodeModalData = {};  // { sourceId, seriesId, seriesName, icon, group, episodes }

        async function updateCartBadge() {
            try {
                const resp = await fetch('/api/cart/status');
                const data = await resp.json();
                const badge = document.getElementById('cart-badge');
                const count = data.queued + data.downloading;
                if (count > 0) {
                    badge.textContent = count;
                    badge.style.display = 'flex';
                } else {
                    badge.style.display = 'none';
                }
            } catch (e) {}
        }

        // Delegated click handler for all cart buttons
        document.addEventListener('click', function(event) {
            const btn = event.target.closest('.add-cart-btn');
            if (!btn) return;
            event.stopPropagation();
            event.preventDefault();
            const sourceId = btn.dataset.sourceId;
            const itemId = btn.dataset.itemId;
            const cType = btn.dataset.contentType;
            const name = btn.dataset.name;
            const icon = btn.dataset.icon;
            const group = btn.dataset.group;
            const allSourcesRaw = btn.dataset.allSources;
            let allSources = null;
            if (allSourcesRaw) {
                try { allSources = JSON.parse(allSourcesRaw); } catch(e) {}
            }
            _handleCartAdd(sourceId, itemId, cType, name, icon, group, allSources);
        });

        async function _handleCartAdd(sourceId, itemId, cType, name, icon, group, allSources) {
            if (cType === 'series') {
                // Open episode selector modal
                openEpisodeModal(sourceId, itemId, name, icon, group, allSources);
                return;
            }
            // VOD: add directly
            try {
                const resp = await fetch('/api/cart', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        source_id: sourceId,
                        stream_id: itemId,
                        content_type: cType,
                        name: name,
                        icon: icon,
                        group: group,
                        container_extension: 'mp4'
                    })
                });
                const data = await resp.json();
                if (resp.ok) {
                    showToast('Added to cart: ' + name, 'success');
                    updateCartBadge();
                } else {
                    showToast(data.error || 'Failed to add', 'error');
                }
            } catch (e) { showToast('Error adding to cart', 'error'); }
        }

        async function openEpisodeModal(sourceId, seriesId, seriesName, icon, group, allSources) {
            const modal = document.getElementById('episode-modal');
            document.getElementById('episode-modal-title').textContent = 'Select Episodes: ' + seriesName;
            document.getElementById('episode-list').innerHTML = '<div class="loading"><div class="loading-spinner"></div><p>Loading episodes...</p></div>';
            modal.classList.add('show');

            _episodeModalData = { sourceId, seriesId, seriesName, icon, group, allSources: allSources || null };

            // Show/build source selector if multiple sources available
            const selectorDiv = document.getElementById('episode-source-selector');
            const selectEl = document.getElementById('episode-source-select');
            if (allSources && allSources.length > 1) {
                selectEl.innerHTML = allSources.map(s =>
                    '<option value="' + escapeAttr(s.source_id) + '|' + escapeAttr(s.item_id) + '|' + escapeAttr(s.name) + '|' + escapeAttr(s.icon) + '|' + escapeAttr(s.group) + '"' + (s.source_id === sourceId ? ' selected' : '') + '>' + escapeHtml(s.source_name) + ' ‚Äî ' + escapeHtml(s.name) + '</option>'
                ).join('');
                selectorDiv.style.display = 'flex';
            } else {
                selectorDiv.style.display = 'none';
            }

            await _loadEpisodesForSource(sourceId, seriesId);
        }

        async function _loadEpisodesForSource(sourceId, seriesId) {
            document.getElementById('episode-list').innerHTML = '<div class="loading"><div class="loading-spinner"></div><p>Loading episodes...</p></div>';
            _episodeModalData.sourceId = sourceId;
            _episodeModalData.seriesId = seriesId;

            try {
                const resp = await fetch('/api/cart/series-episodes/' + sourceId + '/' + seriesId);
                const data = await resp.json();
                if (!resp.ok || !data.seasons) {
                    document.getElementById('episode-list').innerHTML = '<p style="color:#ff4757">Failed to load episodes: ' + (data.error || 'Unknown error') + '</p>';
                    return;
                }
                _episodeModalData.episodes = data;
                renderEpisodeList(data);
            } catch (e) {
                document.getElementById('episode-list').innerHTML = '<p style="color:#ff4757">Error loading episodes</p>';
            }
        }

        function onEpisodeSourceChange() {
            const val = document.getElementById('episode-source-select').value;
            const parts = val.split('|');
            const sourceId = parts[0];
            const seriesId = parts[1];
            const name = parts[2] || _episodeModalData.seriesName;
            const icon = parts[3] || _episodeModalData.icon;
            const grp = parts[4] || _episodeModalData.group;
            _episodeModalData.icon = icon;
            _episodeModalData.group = grp;
            _loadEpisodesForSource(sourceId, seriesId);
        }

        function renderEpisodeList(data) {
            const container = document.getElementById('episode-list');
            const seasons = data.seasons;
            let html = '';

            for (const [seasonNum, episodes] of Object.entries(seasons)) {
                html += '<div class="season-group">';
                html += '<div class="season-header"><h4>Season ' + seasonNum + ' (' + episodes.length + ' episodes)</h4>';
                html += '<button onclick="addSeasonToCart(\'' + seasonNum + '\')">Add Season</button></div>';

                for (const ep of episodes) {
                    html += '<div class="episode-row">' +
                        '<input type="checkbox" data-season="' + seasonNum + '" data-stream-id="' + ep.stream_id + '" data-ep-num="' + ep.episode_num + '" data-title="' + escapeHtml(ep.title || '') + '" data-ext="' + (ep.container_extension || 'mp4') + '">' +
                        '<span class="ep-num">E' + String(ep.episode_num).padStart(2, '0') + '</span>' +
                        '<span class="ep-title">' + escapeHtml(ep.title || 'Episode ' + ep.episode_num) + '</span>' +
                        '<span class="ep-ext">' + (ep.container_extension || 'mp4') + '</span>' +
                        '</div>';
                }
                html += '</div>';
            }
            container.innerHTML = html;
        }

        function closeEpisodeModal() {
            document.getElementById('episode-modal').classList.remove('show');
            _episodeModalData = {};
        }

        async function addAllEpisodesToCart() {
            const d = _episodeModalData;
            try {
                const resp = await fetch('/api/cart', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        source_id: d.sourceId,
                        series_id: d.seriesId,
                        content_type: 'series',
                        add_mode: 'series',
                        name: d.seriesName,
                        series_name: d.seriesName,
                        icon: d.icon,
                        group: d.group
                    })
                });
                const data = await resp.json();
                if (resp.ok) {
                    showToast('Added ' + data.added + ' episodes to cart', 'success');
                    updateCartBadge();
                    closeEpisodeModal();
                } else {
                    showToast(data.error || 'Failed to add episodes', 'error');
                }
            } catch (e) { showToast('Error adding episodes', 'error'); }
        }

        async function addSeasonToCart(seasonNum) {
            const d = _episodeModalData;
            try {
                const resp = await fetch('/api/cart', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        source_id: d.sourceId,
                        series_id: d.seriesId,
                        content_type: 'series',
                        add_mode: 'season',
                        season_num: seasonNum,
                        name: d.seriesName,
                        series_name: d.seriesName,
                        icon: d.icon,
                        group: d.group
                    })
                });
                const data = await resp.json();
                if (resp.ok) {
                    showToast('Added ' + data.added + ' episodes (Season ' + seasonNum + ') to cart', 'success');
                    updateCartBadge();
                } else {
                    showToast(data.error || 'Failed to add season', 'error');
                }
            } catch (e) { showToast('Error adding season', 'error'); }
        }

        async function addSelectedEpisodesToCart() {
            const d = _episodeModalData;
            const checked = document.querySelectorAll('#episode-list input[type="checkbox"]:checked');
            if (checked.length === 0) { showToast('No episodes selected', 'info'); return; }

            let addedCount = 0;
            for (const cb of checked) {
                try {
                    const resp = await fetch('/api/cart', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            source_id: d.sourceId,
                            stream_id: cb.dataset.streamId,
                            content_type: 'series',
                            add_mode: 'episode',
                            name: cb.dataset.title || 'Episode ' + cb.dataset.epNum,
                            series_name: d.seriesName,
                            season: cb.dataset.season,
                            episode_num: parseInt(cb.dataset.epNum),
                            episode_title: cb.dataset.title,
                            icon: d.icon,
                            group: d.group,
                            container_extension: cb.dataset.ext || 'mp4'
                        })
                    });
                    if (resp.ok) addedCount++;
                } catch (e) {}
            }
            showToast('Added ' + addedCount + ' episodes to cart', 'success');
            updateCartBadge();
            closeEpisodeModal();
        }

        // Load cart badge on page load
        updateCartBadge();

        function checkVersion() {
            fetch('/api/version').then(r => r.json()).then(data => {
                const badge = document.getElementById('version-badge');
                if (!badge) return;
                if (data.update_available) {
                    badge.textContent = 'v' + data.current + ' ‚Üí v' + data.latest;
                    badge.style.background = 'rgba(255, 165, 0, 0.15)';
                    badge.style.color = '#ffa500';
                    badge.style.cursor = 'pointer';
                    badge.title = 'Click to view release notes';
                    badge.onclick = function() { window.open(data.release_url, '_blank'); };
                } else {
                    badge.textContent = 'v' + data.current;
                }
                badge.style.display = 'inline-block';
            }).catch(() => {});
        }
        checkVersion();
    </script>
</body>
</html>
