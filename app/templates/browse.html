<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom categories & Downloads - XtreamFilter</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); min-height: 100vh; color: #e0e0e0; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        .top-nav { display: flex; align-items: center; gap: 20px; margin-bottom: 25px; padding: 12px 20px; background: rgba(255, 255, 255, 0.04); border: 1px solid rgba(255, 255, 255, 0.08); border-radius: 12px; flex-wrap: wrap; }
        .top-nav-brand { display: flex; align-items: center; gap: 10px; text-decoration: none; color: #00d4ff; font-weight: 700; font-size: 1.15em; white-space: nowrap; }
        .top-nav-brand:hover { color: #33ddff; }
        .top-nav-links { display: flex; gap: 4px; flex-wrap: wrap; margin-left: auto; }
        .top-nav-link { padding: 8px 16px; border-radius: 8px; background: transparent; border: 1px solid transparent; color: #888; text-decoration: none; font-size: 0.9em; transition: all 0.2s; display: inline-flex; align-items: center; gap: 6px; position: relative; white-space: nowrap; }
        .top-nav-link:hover { color: #fff; background: rgba(255, 255, 255, 0.08); }
        .top-nav-link.active { color: #00d4ff; background: rgba(0, 212, 255, 0.12); border-color: rgba(0, 212, 255, 0.25); }
        .nav-cart-badge { position: absolute; top: 2px; right: 2px; background: #ff4757; color: #fff; font-size: 0.65em; font-weight: 700; min-width: 16px; height: 16px; border-radius: 8px; display: flex; align-items: center; justify-content: center; padding: 0 4px; }
        .nav-version { font-size: 0.7em; padding: 3px 10px; border-radius: 12px; background: rgba(255, 255, 255, 0.08); color: #888; cursor: default; white-space: nowrap; }
        @media (max-width: 768px) { .top-nav { gap: 10px; padding: 10px 14px; } .top-nav-links { margin-left: 0; width: 100%; } .top-nav-link { flex: 1; justify-content: center; padding: 8px 10px; font-size: 0.82em; } }
        .btn { display: inline-block; padding: 10px 20px; border: none; border-radius: 8px; font-size: 0.95em; cursor: pointer; transition: all 0.3s; text-decoration: none; }
        .btn-secondary { background: rgba(255, 255, 255, 0.1); color: #fff; border: 1px solid rgba(255, 255, 255, 0.2); }
        .btn-secondary:hover { background: rgba(255, 255, 255, 0.2); }
        .btn-primary { background: linear-gradient(135deg, #00d4ff, #0099cc); color: #000; font-weight: 600; }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(0, 212, 255, 0.4); }
        .btn-small { padding: 6px 12px; font-size: 0.85em; }
        .btn-danger { background: rgba(255, 71, 87, 0.2); color: #ff4757; border: 1px solid rgba(255, 71, 87, 0.3); }
        .browse-nav { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; background: rgba(255, 255, 255, 0.05); border-radius: 12px; padding: 12px 15px; margin-bottom: 20px; border: 1px solid rgba(255, 255, 255, 0.1); }
        .browse-nav-separator { width: 1px; height: 24px; background: rgba(255, 255, 255, 0.15); flex-shrink: 0; margin: 0 4px; }
        .browse-nav-actions { display: flex; gap: 6px; margin-left: auto; flex-shrink: 0; }
        .btn-icon { padding: 6px 10px; font-size: 1em; line-height: 1; }
        .btn-icon.refreshing { animation: spin 1s linear infinite; pointer-events: none; opacity: 0.6; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .categories-list { display: flex; gap: 8px; flex-wrap: wrap; }
        .category-pill { padding: 8px 16px; border-radius: 20px; background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); color: #888; cursor: pointer; transition: all 0.2s; font-size: 0.85em; display: flex; align-items: center; gap: 6px; }
        .category-pill:hover { background: rgba(255, 255, 255, 0.1); color: #fff; }
        .category-pill.active { background: rgba(0, 212, 255, 0.2); border-color: #00d4ff; color: #00d4ff; }
        .category-pill .cat-count { background: rgba(0, 0, 0, 0.3); padding: 2px 6px; border-radius: 10px; font-size: 0.8em; }
        .controls-bar { background: rgba(255, 255, 255, 0.05); border-radius: 12px; padding: 20px; margin-bottom: 20px; border: 1px solid rgba(255, 255, 255, 0.1); }
        .controls-row { display: flex; gap: 15px; flex-wrap: wrap; align-items: flex-end; }
        .control-group { display: flex; flex-direction: column; gap: 6px; }
        .control-group label { font-size: 0.8em; color: #888; text-transform: uppercase; }
        .control-group input, .control-group select { padding: 10px 14px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; background: rgba(0, 0, 0, 0.3); color: #fff; font-size: 0.95em; min-width: 150px; }
        .control-group input:focus, .control-group select:focus { outline: none; border-color: #00d4ff; }
        .search-input { flex: 1; min-width: 250px; }
        .type-pills { display: flex; gap: 8px; }
        .type-pill { padding: 8px 16px; border-radius: 20px; background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); color: #888; cursor: pointer; transition: all 0.2s; font-size: 0.85em; }
        .type-pill:hover { background: rgba(255, 255, 255, 0.1); color: #fff; }
        .type-pill.active { background: rgba(0, 212, 255, 0.2); border-color: #00d4ff; color: #00d4ff; }
        .stats-bar { display: flex; justify-content: space-between; margin-bottom: 15px; padding: 0 5px; }
        .stats-info { color: #888; font-size: 0.9em; }
        .stats-info strong { color: #00d4ff; }
        .content-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .content-card { background: rgba(255, 255, 255, 0.05); border-radius: 12px; overflow: hidden; border: 1px solid rgba(255, 255, 255, 0.08); transition: all 0.3s; position: relative; }
        .content-card:hover { transform: translateY(-5px); border-color: rgba(0, 212, 255, 0.3); box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3); }
        .card-poster { width: 100%; aspect-ratio: 2/3; object-fit: cover; background: rgba(0, 0, 0, 0.3); display: block; }
        .card-poster-live { aspect-ratio: 16/9; }
        .card-poster-placeholder { width: 100%; aspect-ratio: 2/3; background: linear-gradient(135deg, rgba(0, 212, 255, 0.1) 0%, rgba(0, 0, 0, 0.3) 100%); display: flex; align-items: center; justify-content: center; font-size: 3em; color: rgba(255, 255, 255, 0.2); }
        .card-poster-placeholder.live { aspect-ratio: 16/9; }
        .card-info { padding: 12px; }
        .card-title { font-size: 0.9em; color: #fff; margin-bottom: 6px; line-height: 1.3; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
        .card-meta { display: flex; flex-wrap: wrap; gap: 6px; align-items: center; }
        .card-group { font-size: 0.75em; color: #888; background: rgba(255, 255, 255, 0.05); padding: 3px 8px; border-radius: 4px; }
        .source-badge { font-size: 0.7em; padding: 3px 8px; border-radius: 4px; font-weight: 500; }
        .source-badge[data-color="1"] { background: rgba(46, 213, 115, 0.2); color: #2ed573; }
        .source-badge[data-color="2"] { background: rgba(255, 165, 2, 0.2); color: #ffa502; }
        .source-badge[data-color="3"] { background: rgba(255, 71, 87, 0.2); color: #ff4757; }
        .source-badge[data-color="4"] { background: rgba(116, 185, 255, 0.2); color: #74b9ff; }
        .source-badge[data-color="5"] { background: rgba(162, 155, 254, 0.2); color: #a29bfe; }
        .card-date { font-size: 0.7em; color: #666; margin-top: 4px; }
        .card-rating { font-size: 0.75em; color: #ffa502; display: flex; align-items: center; gap: 3px; }
        .card-rating .star { color: #ffa502; }
        .card-categories { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 6px; }
        .card-cat-badge { font-size: 0.65em; padding: 2px 6px; border-radius: 3px; background: rgba(46, 213, 115, 0.2); color: #2ed573; }
        .add-category-btn { position: absolute; top: 10px; right: 10px; width: 36px; height: 36px; border-radius: 50%; background: rgba(0, 0, 0, 0.6); border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.2em; transition: all 0.2s; color: rgba(255, 255, 255, 0.7); }
        .add-category-btn:hover { transform: scale(1.1); background: rgba(0, 0, 0, 0.8); color: #00d4ff; }
        .add-category-btn.has-categories { color: #2ed573; }
        .category-dropdown { position: absolute; top: 50px; right: 10px; background: rgba(20, 20, 40, 0.98); border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 8px; min-width: 200px; z-index: 100; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5); display: none; }
        .category-dropdown.show { display: block; }
        .category-dropdown-item { padding: 10px 14px; display: flex; align-items: center; gap: 8px; cursor: pointer; transition: background 0.2s; border-bottom: 1px solid rgba(255, 255, 255, 0.05); }
        .category-dropdown-item:last-child { border-bottom: none; }
        .category-dropdown-item:hover { background: rgba(255, 255, 255, 0.1); }
        .category-dropdown-item.in-category { color: #2ed573; }
        .category-dropdown-item .cat-check { width: 18px; text-align: center; }
        .new-badge { position: absolute; top: 10px; left: 10px; background: linear-gradient(135deg, #2ed573, #1abc9c); color: #000; font-size: 0.7em; font-weight: 600; padding: 4px 10px; border-radius: 4px; text-transform: uppercase; }
        .pagination { display: flex; justify-content: center; align-items: center; gap: 10px; margin-top: 30px; flex-wrap: wrap; }
        .pagination button { padding: 10px 20px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; color: #fff; cursor: pointer; transition: all 0.2s; }
        .pagination button:disabled { opacity: 0.4; cursor: not-allowed; }
        .pagination button:not(:disabled):hover { background: rgba(0, 212, 255, 0.2); border-color: #00d4ff; }
        .pagination-info { color: #888; font-size: 0.9em; }
        .empty-state { text-align: center; padding: 60px 20px; color: #666; }
        .empty-state-icon { font-size: 4em; margin-bottom: 20px; opacity: 0.3; }
        .empty-state h3 { color: #888; margin-bottom: 10px; }
        .loading { text-align: center; padding: 60px 20px; color: #888; }
        .loading-spinner { display: inline-block; width: 40px; height: 40px; border: 3px solid rgba(0, 212, 255, 0.1); border-radius: 50%; border-top-color: #00d4ff; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.8); display: none; align-items: center; justify-content: center; z-index: 1000; padding: 20px; }
        .modal-overlay.show { display: flex; }
        .modal { background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 16px; max-width: 600px; width: 100%; max-height: 90vh; overflow-y: auto; }
        .modal-header { padding: 20px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); display: flex; justify-content: space-between; align-items: center; }
        .modal-header h2 { color: #00d4ff; font-size: 1.3em; }
        .modal-close { background: none; border: none; color: #888; font-size: 1.5em; cursor: pointer; }
        .modal-close:hover { color: #fff; }
        .modal-body { padding: 20px; }
        .modal-footer { padding: 20px; border-top: 1px solid rgba(255, 255, 255, 0.1); display: flex; justify-content: flex-end; gap: 10px; }
        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; margin-bottom: 8px; color: #888; font-size: 0.9em; }
        .form-group input[type="text"], .form-group select { width: 100%; padding: 12px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; background: rgba(0, 0, 0, 0.3); color: #fff; font-size: 1em; }
        .form-row { display: flex; gap: 15px; }
        .form-row .form-group { flex: 1; }
        .icon-picker { display: flex; flex-wrap: wrap; gap: 8px; }
        .icon-option { width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; cursor: pointer; font-size: 1.3em; }
        .icon-option:hover { background: rgba(255, 255, 255, 0.1); }
        .icon-option.selected { background: rgba(0, 212, 255, 0.2); border-color: #00d4ff; }
        .mode-toggle { display: flex; gap: 10px; }
        .mode-option { flex: 1; padding: 15px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; cursor: pointer; text-align: center; }
        .mode-option:hover { background: rgba(255, 255, 255, 0.05); }
        .mode-option.selected { background: rgba(0, 212, 255, 0.15); border-color: #00d4ff; }
        .mode-option h4 { color: #fff; margin-bottom: 5px; }
        .mode-option p { font-size: 0.8em; color: #888; }
        .content-types-grid { display: flex; gap: 15px; }
        .content-type-checkbox { flex: 1; padding: 12px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; cursor: pointer; text-align: center; }
        .content-type-checkbox.selected { background: rgba(0, 212, 255, 0.15); border-color: #00d4ff; }
        .content-type-checkbox input { display: none; }
        .patterns-section { display: none; }
        .patterns-section.show { display: block; }
        .pattern-row { display: flex; gap: 10px; margin-bottom: 10px; align-items: center; }
        .pattern-row select { width: 140px; padding: 10px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; background: rgba(0, 0, 0, 0.3); color: #fff; }
        .pattern-row input { flex: 1; padding: 10px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; background: rgba(0, 0, 0, 0.3); color: #fff; }
        .pattern-row button { padding: 8px 12px; border: none; border-radius: 6px; cursor: pointer; background: rgba(255, 71, 87, 0.2); color: #ff4757; }
        .add-pattern-btn { padding: 8px 16px; border: 1px dashed rgba(255, 255, 255, 0.2); border-radius: 6px; background: transparent; color: #888; cursor: pointer; width: 100%; margin-top: 10px; }
        .add-pattern-btn:hover { border-color: #00d4ff; color: #00d4ff; }
        .pattern-logic { margin-top: 15px; display: flex; gap: 10px; align-items: center; }
        .pattern-logic label { color: #888; }
        .checkbox-option { display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 10px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; }
        .checkbox-option input[type="checkbox"] { width: 18px; height: 18px; }
        .categories-manage-list { margin-top: 15px; }
        .category-manage-item { display: flex; justify-content: space-between; align-items: center; padding: 12px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; margin-bottom: 8px; background: rgba(0, 0, 0, 0.2); }
        .category-manage-info { display: flex; align-items: center; gap: 10px; }
        .category-manage-info .icon { font-size: 1.3em; }
        .category-manage-info .name { font-weight: 500; }
        .category-manage-info .meta { font-size: 0.8em; color: #888; }
        .category-manage-actions { display: flex; gap: 8px; }
        .toast { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%) translateY(100px); padding: 12px 24px; border-radius: 8px; font-size: 0.95em; z-index: 10000; opacity: 0; transition: all 0.3s ease; }
        .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
        .toast-success { background: linear-gradient(135deg, #2ed573, #1abc9c); color: #000; font-weight: 500; }
        .toast-info { background: rgba(0, 212, 255, 0.9); color: #000; font-weight: 500; }
        .toast-error { background: rgba(255, 71, 87, 0.9); color: #fff; font-weight: 500; }
        /* Grouped items (category view) */
        .sources-badge { display: inline-flex; align-items: center; gap: 4px; font-size: 0.7em; padding: 3px 8px; border-radius: 4px; background: rgba(0, 212, 255, 0.15); color: #00d4ff; cursor: pointer; margin-left: 4px; }
        .sources-toggle { display: flex; align-items: center; justify-content: center; padding: 6px; cursor: pointer; border-top: 1px solid rgba(255, 255, 255, 0.05); color: #888; font-size: 0.8em; transition: all 0.2s; user-select: none; }
        .sources-toggle:hover { background: rgba(255, 255, 255, 0.05); color: #00d4ff; }
        .sources-toggle .arrow { display: inline-block; transition: transform 0.2s; margin-right: 4px; }
        .sources-toggle.expanded .arrow { transform: rotate(180deg); }
        .sources-list { display: none; border-top: 1px solid rgba(255, 255, 255, 0.05); background: rgba(0, 0, 0, 0.2); }
        .sources-list.show { display: block; }
        .source-row { display: flex; flex-direction: column; gap: 4px; padding: 8px 12px; border-bottom: 1px solid rgba(255, 255, 255, 0.03); font-size: 0.8em; }
        .source-row:last-child { border-bottom: none; }
        .source-row .source-row-name { color: #ccc; word-break: break-word; line-height: 1.3; }
        .source-row .source-row-meta { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }
        .source-row .source-row-group { color: #888; font-size: 0.9em; background: rgba(255, 255, 255, 0.05); padding: 2px 6px; border-radius: 3px; }
        .source-row .source-row-actions { display: flex; gap: 4px; margin-left: auto; }
        .source-row .source-row-cat-btn { width: 24px; height: 24px; border-radius: 50%; background: rgba(0, 0, 0, 0.4); border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 0.9em; color: rgba(255, 255, 255, 0.5); transition: all 0.2s; }
        .source-row .source-row-cat-btn:hover { color: #00d4ff; background: rgba(0, 0, 0, 0.6); }
        .source-row .source-row-cat-btn.has-categories { color: #2ed573; }
        /* Cart button styles */
        .add-cart-btn { position: absolute; top: 10px; right: 52px; width: 36px; height: 36px; border-radius: 50%; background: rgba(0, 0, 0, 0.6); border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.1em; transition: all 0.2s; color: rgba(255, 255, 255, 0.7); }
        .add-cart-btn:hover { transform: scale(1.1); background: rgba(0, 0, 0, 0.8); color: #2ed573; }
        .source-row .source-row-cart-btn { width: 24px; height: 24px; border-radius: 50%; background: rgba(0, 0, 0, 0.4); border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 0.85em; color: rgba(255, 255, 255, 0.5); transition: all 0.2s; }
        .source-row .source-row-cart-btn:hover { color: #2ed573; background: rgba(0, 0, 0, 0.6); }
        /* Monitor button */
        .add-monitor-btn { position: absolute; top: 10px; right: 94px; width: 36px; height: 36px; border-radius: 50%; background: rgba(0, 0, 0, 0.6); border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.1em; transition: all 0.2s; color: rgba(255, 255, 255, 0.7); }
        .add-monitor-btn:hover { transform: scale(1.1); background: rgba(0, 0, 0, 0.8); color: #a29bfe; }
        /* Monitor modal form */
        .monitor-form .form-group { margin-bottom: 15px; }
        .monitor-form .form-group label { display: block; margin-bottom: 6px; color: #888; font-size: 0.9em; }
        .monitor-form .scope-options { display: flex; gap: 8px; flex-wrap: wrap; }
        .monitor-form .scope-option { padding: 10px 16px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; cursor: pointer; text-align: center; transition: all 0.2s; flex: 1; min-width: 90px; }
        .monitor-form .scope-option:hover { background: rgba(255, 255, 255, 0.05); }
        .monitor-form .scope-option.selected { background: rgba(0, 212, 255, 0.15); border-color: #00d4ff; color: #00d4ff; }
        .monitor-form .scope-option .scope-title { font-weight: 600; font-size: 0.95em; margin-bottom: 3px; }
        .monitor-form .scope-option .scope-desc { font-size: 0.75em; color: #888; }
        .monitor-form select { width: 100%; padding: 10px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; background: rgba(0, 0, 0, 0.3); color: #fff; font-size: 0.95em; }
        .monitor-form .source-options { display: flex; gap: 8px; flex-wrap: wrap; }
        .monitor-form .source-option { padding: 10px 16px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; cursor: pointer; transition: all 0.2s; flex: 1; min-width: 120px; text-align: center; }
        .monitor-form .source-option:hover { background: rgba(255, 255, 255, 0.05); }
        .monitor-form .source-option.selected { background: rgba(162, 155, 254, 0.15); border-color: #a29bfe; color: #a29bfe; }
        /* Episode selector modal */
        .episode-list { max-height: 400px; overflow-y: auto; }
        .season-group { margin-bottom: 15px; }
        .season-header { display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; margin-bottom: 8px; cursor: pointer; }
        .season-header h4 { color: #00d4ff; font-size: 0.95em; }
        .season-header button { padding: 4px 12px; border: 1px solid rgba(0, 212, 255, 0.3); border-radius: 6px; background: transparent; color: #00d4ff; cursor: pointer; font-size: 0.8em; }
        .season-header button:hover { background: rgba(0, 212, 255, 0.15); }
        .episode-row { display: flex; align-items: center; gap: 10px; padding: 8px 12px; border-bottom: 1px solid rgba(255, 255, 255, 0.05); font-size: 0.9em; cursor: pointer; }
        .episode-row:hover { background: rgba(0, 212, 255, 0.06); }
        .episode-row input[type="checkbox"] { width: 18px; height: 18px; flex-shrink: 0; }
        .episode-row .ep-num { color: #888; min-width: 40px; }
        .episode-row .ep-title { flex: 1; }
        .episode-row .ep-ext { color: #666; font-size: 0.85em; }
        .episode-actions { display: flex; gap: 10px; margin-bottom: 15px; }
        .episode-source-selector { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; padding: 10px 12px; background: rgba(0, 0, 0, 0.2); border-radius: 8px; }
        .episode-source-selector label { color: #888; font-size: 0.9em; white-space: nowrap; }
        .episode-source-selector select { flex: 1; padding: 6px 10px; border-radius: 6px; border: 1px solid rgba(255, 255, 255, 0.1); background: rgba(0, 0, 0, 0.3); color: #e0e0e0; font-size: 0.9em; }
        .episode-source-selector select:focus { border-color: #00d4ff; outline: none; }
        .type-badge { display: inline-block; font-size: 0.7em; padding: 1px 7px; border-radius: 8px; font-weight: 600; margin-left: 6px; vertical-align: middle; }
        .type-badge-vod { background: rgba(255, 107, 107, 0.25); color: #ff6b6b; }
        .type-badge-series { background: rgba(46, 213, 115, 0.25); color: #2ed573; }
        .type-badge-live { background: rgba(0, 212, 255, 0.25); color: #00d4ff; }
        @media (max-width: 768px) { .controls-row { flex-direction: column; } .control-group { width: 100%; } .content-grid { grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 12px; } .form-row { flex-direction: column; } }

        /* ---- Player Modal ---- */
        .player-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.92); z-index: 10000; display: none; flex-direction: column; align-items: center; justify-content: center; }
        .player-overlay.show { display: flex; }
        .player-container { position: relative; width: 90vw; max-width: 1200px; background: #111; border-radius: 12px; overflow: hidden; box-shadow: 0 20px 60px rgba(0,0,0,0.8); }
        .player-header { display: flex; align-items: center; gap: 12px; padding: 12px 16px; background: rgba(0,0,0,0.6); }
        .player-title { flex: 1; font-weight: 600; color: #fff; font-size: 1em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .player-source-badge { font-size: 0.75em; padding: 2px 8px; border-radius: 6px; background: rgba(0,212,255,0.2); color: #00d4ff; }
        .player-close-btn { background: none; border: none; color: #888; font-size: 1.4em; cursor: pointer; padding: 4px 8px; border-radius: 6px; transition: all 0.2s; }
        .player-close-btn:hover { color: #fff; background: rgba(255,255,255,0.1); }
        .player-video-wrap { position: relative; width: 100%; background: #000; aspect-ratio: 16 / 9; }
        .player-video-wrap video { width: 100%; height: 100%; display: block; background: #000; }
        .player-loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: flex; flex-direction: column; align-items: center; gap: 12px; color: #888; z-index: 2; }
        .player-loading .loading-spinner { width: 40px; height: 40px; border: 3px solid rgba(255,255,255,0.1); border-top-color: #00d4ff; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .player-error { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #ff4757; z-index: 2; display: none; }
        .player-error h3 { margin-bottom: 10px; }
        .player-error .btn { margin-top: 10px; }
        .player-epg { padding: 10px 16px; background: rgba(0,0,0,0.5); display: none; }
        .player-epg.visible { display: block; }
        .player-epg-current { display: flex; align-items: center; gap: 10px; margin-bottom: 4px; }
        .player-epg-label { font-size: 0.7em; text-transform: uppercase; color: #00d4ff; font-weight: 600; padding: 2px 6px; border-radius: 4px; background: rgba(0,212,255,0.15); }
        .player-epg-title { color: #fff; font-size: 0.9em; flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .player-epg-time { color: #888; font-size: 0.8em; white-space: nowrap; }
        .player-epg-progress { height: 3px; background: rgba(255,255,255,0.1); border-radius: 2px; margin: 6px 0; }
        .player-epg-progress-bar { height: 100%; background: #00d4ff; border-radius: 2px; transition: width 1s linear; }
        .player-epg-next { display: flex; align-items: center; gap: 10px; }
        .player-epg-next .player-epg-label { background: rgba(255,255,255,0.08); color: #888; }
        .player-footer { padding: 8px 16px; background: rgba(0,0,0,0.4); display: flex; gap: 8px; align-items: center; justify-content: flex-end; }
        .player-footer .btn { padding: 6px 12px; font-size: 0.8em; }
        .play-btn { position: absolute; top: 4px; left: 4px; background: rgba(0,0,0,0.7); border: none; color: #fff; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; font-size: 0.9em; display: flex; align-items: center; justify-content: center; opacity: 0; transition: opacity 0.2s; z-index: 3; }
        .content-card:hover .play-btn { opacity: 1; }
        .play-btn:hover { background: rgba(0,212,255,0.8); transform: scale(1.1); }
        .episode-play-btn { background: rgba(0,212,255,0.12); border: 1px solid rgba(0,212,255,0.3); color: #00d4ff; cursor: pointer; font-size: 1.05em; padding: 4px 10px; border-radius: 6px; transition: all 0.2s; flex-shrink: 0; }
        .episode-play-btn:hover { background: rgba(0,212,255,0.3); border-color: #00d4ff; transform: scale(1.05); }
        /* Custom VOD seek bar for transcoded streams */
        .player-seekbar { display: none; padding: 8px 16px; background: rgba(0,0,0,0.6); }
        .player-seekbar.visible { display: flex; align-items: center; gap: 10px; }
        .player-seekbar-track { flex: 1; height: 6px; background: rgba(255,255,255,0.15); border-radius: 3px; cursor: pointer; position: relative; }
        .player-seekbar-track:hover { height: 8px; }
        .player-seekbar-filled { height: 100%; background: #00d4ff; border-radius: 3px; pointer-events: none; transition: width 0.3s linear; }
        .player-seekbar-time { color: #ccc; font-size: 0.8em; font-variant-numeric: tabular-nums; min-width: 100px; text-align: center; white-space: nowrap; }
        /* Audio track selector */
        .player-audio-select { display: none; padding: 4px 16px 6px; background: rgba(0,0,0,0.6); align-items: center; gap: 10px; }
        .player-audio-select.visible { display: flex; }
        .player-audio-select label { color: #ccc; font-size: 0.85em; white-space: nowrap; }
        .player-audio-select select { background: #1e1e2e; color: #e0e0e0; border: 1px solid rgba(255,255,255,0.15); border-radius: 6px; padding: 4px 10px; font-size: 0.85em; cursor: pointer; max-width: 400px; outline: none; }
        .player-audio-select select:hover { border-color: #00d4ff; }
        @media (max-width: 768px) { .player-container { width: 100vw; border-radius: 0; } .player-video-wrap { aspect-ratio: auto; height: 56vw; } }
    </style>
    <!-- Player JS libraries -->
    <script src="https://cdn.jsdelivr.net/npm/mpegts.js@1.7.3/dist/mpegts.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.5.7/dist/hls.min.js"></script>
</head>
<body>
    <div class="container">
        <nav class="top-nav">
            <a href="/" class="top-nav-brand">üì∫ XtreamFilter</a>
            <span id="version-badge" class="nav-version" style="display:none"></span>
            <div class="top-nav-links">
                <a href="/" class="top-nav-link">‚öôÔ∏è Settings</a>
                <a href="/browse" class="top-nav-link active">üîç Browse</a>
                <a href="/cart" class="top-nav-link">üõí Cart<span class="nav-cart-badge" id="cart-badge" style="display:none">0</span></a>
                <a href="/monitor" class="top-nav-link">üì° Monitor</a>
            </div>
        </nav>
        <div class="browse-nav" id="browse-nav"></div>
        <div class="controls-bar" id="controls-bar">
            <div class="controls-row">
                <div class="control-group search-input">
                    <label>Search</label>
                    <div style="display: flex; gap: 8px;">
                        <input type="text" id="search-input" placeholder="Search films, series, channels..." onkeypress="if(event.key==='Enter')applyFilters()">
                        <button class="btn btn-primary" onclick="currentPage=1;applyFilters()" style="white-space: nowrap;">üîç Search</button>
                    </div>
                </div>
                <div class="control-group">
                    <label>Content Type</label>
                    <div class="type-pills">
                        <div class="type-pill" data-type="vod" onclick="setContentType('vod')">Films</div>
                        <div class="type-pill" data-type="series" onclick="setContentType('series')">Series</div>
                        <div class="type-pill active" data-type="live" onclick="setContentType('live')">Channels</div>
                    </div>
                </div>
                <div class="control-group">
                    <label>Source</label>
                    <select id="source-filter"><option value="">All Sources</option></select>
                </div>
                <div class="control-group">
                    <label>Group</label>
                    <select id="group-filter"><option value="">All Groups</option></select>
                </div>
                <div class="control-group">
                    <label>&nbsp;</label>
                    <label class="checkbox-option" style="padding: 10px 14px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="use-source-filters-browse" style="width: 18px; height: 18px;">
                        <span style="white-space: nowrap;">Apply source filter rules</span>
                    </label>
                </div>
            </div>
            <div class="controls-row" id="sort-filter-row" style="margin-top: 12px; display: none;">
                <div class="control-group">
                    <label>Sort By</label>
                    <select id="sort-by" onchange="currentPage=1;applyFilters()">
                        <option value="">Default</option>
                        <option value="name">Name</option>
                        <option value="added">Added Date</option>
                        <option value="rating">Rating</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Order</label>
                    <select id="sort-order" onchange="currentPage=1;applyFilters()">
                        <option value="desc">Descending</option>
                        <option value="asc">Ascending</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Min Rating</label>
                    <select id="min-rating" onchange="currentPage=1;applyFilters()">
                        <option value="0">Any</option>
                        <option value="1">1+</option>
                        <option value="2">2+</option>
                        <option value="3">3+</option>
                        <option value="4">4+</option>
                        <option value="5">5+</option>
                        <option value="6">6+</option>
                        <option value="7">7+</option>
                        <option value="8">8+</option>
                        <option value="9">9+</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Added Within</label>
                    <select id="max-added-days" onchange="currentPage=1;applyFilters()">
                        <option value="0">Any time</option>
                        <option value="1">Last 24h</option>
                        <option value="7">Last 7 days</option>
                        <option value="14">Last 14 days</option>
                        <option value="30">Last 30 days</option>
                        <option value="90">Last 3 months</option>
                        <option value="180">Last 6 months</option>
                        <option value="365">Last year</option>
                    </select>
                </div>
            </div>
        </div>
        <div class="stats-bar"><div class="stats-info">Showing <strong id="showing-count">0</strong> of <strong id="total-count">0</strong> items</div></div>
        <div id="loading-state" class="loading" style="display: none;"><div class="loading-spinner"></div><p>Loading content...</p></div>
        <div id="empty-state" class="empty-state" style="display: none;"><div class="empty-state-icon">No results</div><h3>No content found</h3><p>Try adjusting your filters or search terms</p></div>
        <div class="content-grid" id="content-grid"></div>
        <div class="pagination" id="pagination" style="display: none;">
            <button onclick="goToPage(1)" id="first-page-btn">First</button>
            <button onclick="goToPage(currentPage - 1)" id="prev-page-btn">Previous</button>
            <span class="pagination-info">Page <strong id="current-page">1</strong> of <strong id="total-pages">1</strong></span>
            <button onclick="goToPage(currentPage + 1)" id="next-page-btn">Next</button>
            <button onclick="goToPage(totalPages)" id="last-page-btn">Last</button>
        </div>
    </div>

    <!-- Category Modal -->
    <div class="modal-overlay" id="category-modal">
        <div class="modal">
            <div class="modal-header">
                <h2 id="category-modal-title">Create Category</h2>
                <button class="modal-close" onclick="closeCategoryModal()">&times;</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="category-edit-id">
                <div class="form-row">
                    <div class="form-group">
                        <label>Category Name</label>
                        <input type="text" id="category-name" placeholder="My Category">
                    </div>
                    <div class="form-group">
                        <label>Icon</label>
                        <div class="icon-picker" id="icon-picker">
                            <div class="icon-option selected" data-icon="folder">üìÅ</div>
                            <div class="icon-option" data-icon="heart">‚ù§Ô∏è</div>
                            <div class="icon-option" data-icon="star">‚≠ê</div>
                            <div class="icon-option" data-icon="film">üé¨</div>
                            <div class="icon-option" data-icon="tv">üì∫</div>
                            <div class="icon-option" data-icon="game">üéÆ</div>
                            <div class="icon-option" data-icon="music">üéµ</div>
                            <div class="icon-option" data-icon="sport">üèÄ</div>
                            <div class="icon-option" data-icon="fire">üî•</div>
                            <div class="icon-option" data-icon="bookmark">üîñ</div>
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <label>Mode</label>
                    <div class="mode-toggle">
                        <div class="mode-option selected" data-mode="manual" onclick="selectMode('manual')">
                            <h4>Manual</h4>
                            <p>Add items yourself</p>
                        </div>
                        <div class="mode-option" data-mode="automatic" onclick="selectMode('automatic')">
                            <h4>Automatic</h4>
                            <p>Use search patterns</p>
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <label>Content Types</label>
                    <div class="content-types-grid">
                        <div class="content-type-checkbox selected" data-type="live" onclick="toggleContentType(this)">
                            Channels
                        </div>
                        <div class="content-type-checkbox selected" data-type="vod" onclick="toggleContentType(this)">
                            Films
                        </div>
                        <div class="content-type-checkbox selected" data-type="series" onclick="toggleContentType(this)">
                            Series
                        </div>
                    </div>
                </div>
                <div class="patterns-section" id="patterns-section">
                    <div class="form-group">
                        <label>Recently Added Filter</label>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                <input type="checkbox" id="use-recently-added" onchange="toggleRecentlyAdded()" style="width: 18px; height: 18px;">
                                <span>Only include items added within</span>
                            </label>
                            <select id="recently-added-days" disabled style="padding: 8px 12px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; background: rgba(0, 0, 0, 0.3); color: #fff;">
                                <option value="7">Last 7 days</option>
                                <option value="14">Last 14 days</option>
                                <option value="30">Last 30 days</option>
                                <option value="60">Last 60 days</option>
                                <option value="90">Last 90 days</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Search Patterns (matches item name) - Optional</label>
                        <div id="patterns-container">
                            <div class="pattern-row">
                                <select>
                                    <option value="contains">Contains</option>
                                    <option value="not_contains">Does not contain</option>
                                    <option value="starts_with">Starts with</option>
                                    <option value="ends_with">Ends with</option>
                                    <option value="exact">Exact match</option>
                                    <option value="regex">Regex</option>
                                </select>
                                <input type="text" placeholder="e.g. 4K, Sport, Movie">
                                <button onclick="removePattern(this)">X</button>
                            </div>
                        </div>
                        <button class="add-pattern-btn" onclick="addPattern()">+ Add Pattern</button>
                    </div>
                    <div class="pattern-logic">
                        <label>Match logic:</label>
                        <select id="pattern-logic">
                            <option value="or">Match ANY pattern (OR)</option>
                            <option value="and">Match ALL patterns (AND)</option>
                        </select>
                    </div>
                    <div class="form-group" style="margin-top: 15px;">
                        <label class="checkbox-option">
                            <input type="checkbox" id="use-source-filters">
                            <span>Apply source filter rules</span>
                        </label>
                    </div>
                    <div class="form-group" style="margin-top: 10px;">
                        <label class="checkbox-option">
                            <input type="checkbox" id="notify-telegram">
                            <span>üì± Send Telegram notification when new items are found</span>
                        </label>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeCategoryModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveCategory()">Save Category</button>
            </div>
        </div>
    </div>
    <!-- Manage Categories Modal -->
    <div class="modal-overlay" id="manage-modal">
        <div class="modal">
            <div class="modal-header">
                <h2>Manage Categories</h2>
                <button class="modal-close" onclick="closeManageCategoriesModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="categories-manage-list" id="categories-manage-list"></div>
                <button class="btn btn-primary" style="margin-top: 15px; width: 100%;" onclick="closeManageCategoriesModal(); openCategoryModal();">+ Create New Category</button>
            </div>
        </div>
    </div>
    <!-- Episode Selector Modal -->
    <div class="modal-overlay" id="episode-modal">
        <div class="modal" style="max-width: 700px;">
            <div class="modal-header">
                <h2 id="episode-modal-title">Select Episodes</h2>
                <button class="modal-close" onclick="closeEpisodeModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="episode-source-selector" id="episode-source-selector" style="display:none">
                    <label>Source:</label>
                    <select id="episode-source-select" onchange="onEpisodeSourceChange()"></select>
                </div>
                <div class="episode-actions">
                    <button class="btn btn-primary btn-small" onclick="addAllEpisodesToCart()">Add All Episodes</button>
                    <button class="btn btn-secondary btn-small" onclick="addSelectedEpisodesToCart()">Add Selected</button>
                </div>
                <div class="episode-list" id="episode-list">
                    <div class="loading"><div class="loading-spinner"></div><p>Loading episodes...</p></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeEpisodeModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Series Monitor Modal -->
    <div class="modal-overlay" id="monitor-modal">
        <div class="modal" style="max-width: 500px;">
            <div class="modal-header">
                <h2 id="monitor-modal-title">üì° Monitor Series</h2>
                <button class="modal-close" onclick="closeMonitorModal()">&times;</button>
            </div>
            <div class="modal-body monitor-form">
                <div class="form-group">
                    <label>What to monitor</label>
                    <div class="scope-options">
                        <div class="scope-option selected" data-scope="new_only" onclick="selectMonitorScope('new_only')">
                            <div class="scope-title">New Only</div>
                            <div class="scope-desc">Future episodes</div>
                        </div>
                        <div class="scope-option" data-scope="all" onclick="selectMonitorScope('all')">
                            <div class="scope-title">All</div>
                            <div class="scope-desc">Every episode</div>
                        </div>
                        <div class="scope-option" data-scope="season" onclick="selectMonitorScope('season')">
                            <div class="scope-title">Season</div>
                            <div class="scope-desc">One season</div>
                        </div>
                    </div>
                </div>
                <div class="form-group" id="monitor-season-group" style="display:none;">
                    <label>Season</label>
                    <select id="monitor-season-select"><option value="">Loading...</option></select>
                </div>
                <div class="form-group">
                    <label>Source</label>
                    <div class="source-options" id="monitor-source-options">
                        <div class="source-option selected" data-source="any" onclick="selectMonitorSource('any')">
                            Any source (first found)
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <label>Action</label>
                    <div class="scope-options">
                        <div class="scope-option action-option selected" data-action="both" onclick="selectMonitorAction('both')">
                            <div class="scope-title">Both</div>
                            <div class="scope-desc">Download + Notify</div>
                        </div>
                        <div class="scope-option action-option" data-action="download" onclick="selectMonitorAction('download')">
                            <div class="scope-title">Download</div>
                            <div class="scope-desc">Download only</div>
                        </div>
                        <div class="scope-option action-option" data-action="notify" onclick="selectMonitorAction('notify')">
                            <div class="scope-title">Notify</div>
                            <div class="scope-desc">Telegram only</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeMonitorModal()">Cancel</button>
                <button class="btn btn-primary" onclick="confirmMonitor()">üì° Start Monitoring</button>
            </div>
        </div>
    </div>

    <!-- VOD Source Selector Modal -->
    <div class="modal-overlay" id="vod-source-modal">
        <div class="modal" style="max-width: 500px;">
            <div class="modal-header">
                <h2 id="vod-source-modal-title">Select Source</h2>
                <button class="modal-close" onclick="closeVodSourceModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p style="color:#888; margin-bottom:15px; font-size:0.9em;">This film is available from multiple sources. Choose which one to download:</p>
                <div id="vod-source-list"></div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeVodSourceModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Player Modal -->
    <div class="player-overlay" id="player-modal">
        <div id="player-container" class="player-container">
            <div class="player-header">
                <span class="player-title" id="player-title"></span>
                <span class="player-source-badge" id="player-source-badge"></span>
                <button class="player-close-btn" onclick="closePlayer()" title="Close (Esc)">&times;</button>
            </div>
            <div class="player-video-wrap" id="player-video-wrap">
                <video id="player-video" controls autoplay playsinline></video>
                <div class="player-loading" id="player-loading">
                    <div class="loading-spinner"></div>
                    <span>Loading stream...</span>
                </div>
                <div class="player-error" id="player-error">
                    <h3>‚ö†Ô∏è Playback Error</h3>
                    <p id="player-error-msg">Could not play this stream in the browser.</p>
                    <button class="btn btn-secondary" onclick="copyStreamUrl()">üìã Copy Stream URL</button>
                    <button class="btn btn-secondary" onclick="openInVlc()">‚ñ∂Ô∏è Open in VLC</button>
                </div>
            </div>
            <div class="player-epg" id="player-epg">
                <div class="player-epg-current">
                    <span class="player-epg-label">NOW</span>
                    <span class="player-epg-title" id="player-epg-current-title"></span>
                    <span class="player-epg-time" id="player-epg-current-time"></span>
                </div>
                <div class="player-epg-progress"><div class="player-epg-progress-bar" id="player-epg-progress-bar"></div></div>
                <div class="player-epg-next">
                    <span class="player-epg-label">NEXT</span>
                    <span class="player-epg-title" id="player-epg-next-title"></span>
                    <span class="player-epg-time" id="player-epg-next-time"></span>
                </div>
            </div>
            <!-- Audio track selector -->
            <div class="player-audio-select" id="player-audio-select">
                <label>üîä Audio:</label>
                <select id="player-audio-track" onchange="switchAudioTrack(this.value)"></select>
            </div>
            <!-- Custom seek bar for transcoded VOD (native controls can't seek) -->
            <div class="player-seekbar" id="player-seekbar">
                <span class="player-seekbar-time" id="player-seekbar-pos">0:00 / 0:00</span>
                <div class="player-seekbar-track" id="player-seekbar-track">
                    <div class="player-seekbar-filled" id="player-seekbar-filled"></div>
                </div>
            </div>
            <div class="player-footer">
                <button class="btn btn-secondary" onclick="copyStreamUrl()" title="Copy direct stream URL">üìã Copy URL</button>
                <button class="btn btn-secondary" onclick="closePlayer()">Close</button>
            </div>
        </div>
    </div>

    <script>
        // ---- Player State ----
        let _playerInstance = null;   // mpegts.Player or Hls instance
        let _playerStreamUrl = '';    // Direct stream URL (for copy/VLC)
        let _playerEpgInterval = null;
        let _playerEpgChannelId = null;
        let _playerVolume = parseFloat(localStorage.getItem('playerVolume') || '1');
        // VOD transcode seeking state
        let _playerDuration = 0;      // Total duration in seconds (from ffprobe)
        let _playerSeekOffset = 0;    // Current seek offset sent to ffmpeg
        let _playerTranscodeBase = ''; // Base transcode URL (without start=)
        let _playerIsTranscodedVod = false;
        let _playerSeekBarInterval = null;
        let _playerAudioTrack = -1;   // -1 = default (first audio)
        let _playerAudioTracks = [];  // Array from ffprobe

        function detectPlayerStrategy(contentType, fmt) {
            // Live streams are ALWAYS transcoded server-side via ffmpeg
            if (contentType === 'live') return 'transcode';
            // VOD / series
            if (fmt === 'm3u8') return 'hls';
            if (['mp4', 'm4v', 'webm', 'ogg'].includes(fmt)) return 'native';
            // mkv, avi, etc. ‚Äî transcode to fMP4
            return 'transcode';
        }

        async function openPlayer(contentType, sourceId, itemId, name, icon, group, ext, sourceIndex) {
            // Find source index from sourceId if not provided
            if (sourceIndex === undefined || sourceIndex === null) {
                sourceIndex = sources.findIndex(s => s.id === sourceId);
                if (sourceIndex < 0) sourceIndex = 0;
            }
            const fmt = (ext || (contentType === 'live' ? 'ts' : 'mp4')).toLowerCase();

            // Show the modal immediately
            const modal = document.getElementById('player-modal');
            const video = document.getElementById('player-video');
            const loading = document.getElementById('player-loading');
            const errorDiv = document.getElementById('player-error');
            modal.classList.add('show');
            loading.style.display = 'flex';
            errorDiv.style.display = 'none';
            video.style.display = 'block';
            document.getElementById('player-title').textContent = name || 'Stream';
            const srcName = sources.find(s => s.id === sourceId)?.name || sourceId || '';
            document.getElementById('player-source-badge').textContent = srcName;

            // Set saved volume
            video.volume = _playerVolume;

            // Save volume changes
            video.onvolumechange = function() {
                _playerVolume = video.volume;
                localStorage.setItem('playerVolume', String(video.volume));
            };

            try {
                // Fetch player info from backend
                const resp = await fetch('/api/player/info/' + contentType + '/' + sourceIndex + '/' + itemId + '?ext=' + fmt);
                if (!resp.ok) throw new Error('Failed to get stream info');
                const info = await resp.json();

                const strategy = detectPlayerStrategy(contentType, info.format);

                // Build stream URL ‚Äî live & non-native containers go via transcode,
                // native formats (mp4, webm) use direct proxy.
                let streamUrl;
                _playerIsTranscodedVod = false;
                _playerDuration = info.duration || 0;
                _playerSeekOffset = 0;
                _playerTranscodeBase = '';
                _playerAudioTrack = -1;
                _playerAudioTracks = info.audio_tracks || [];

                if (strategy === 'transcode') {
                    // VOD/series: use audio_only only when video codec is browser-native (h264/vp8/vp9/av1)
                    // Otherwise full transcode (HEVC, MPEG2, etc.)
                    let transcodeUrl = '/api/player/transcode/' + contentType + '/' + sourceIndex + '/' + itemId + '?ext=' + fmt;
                    if (contentType !== 'live') {
                        const vc = (info.video_codec || '').toLowerCase();
                        const browserNativeVideo = ['h264', 'vp8', 'vp9', 'av1'].includes(vc);
                        if (browserNativeVideo) {
                            transcodeUrl += '&audio_only=true';
                        }
                        _playerIsTranscodedVod = true;
                    }
                    _playerTranscodeBase = transcodeUrl;
                    streamUrl = transcodeUrl;
                } else {
                    streamUrl = '/api/player/stream/' + contentType + '/' + sourceIndex + '/' + itemId + '?ext=' + fmt;
                    hideAudioTrackSelector();
                }
                // Keep the direct stream URL for "Copy URL ‚Üí VLC"
                _playerStreamUrl = '/api/player/stream/' + contentType + '/' + sourceIndex + '/' + itemId + '?ext=' + fmt;

                // Tear down any previous player
                destroyPlayerInstance();

                // Show audio track selector if multiple tracks (after destroy, which hides it)
                if (strategy === 'transcode' && _playerAudioTracks.length > 1) {
                    showAudioTrackSelector(_playerAudioTracks, strategy);
                }

                // Hide loading when video starts playing
                video.onplaying = function() { loading.style.display = 'none'; };
                video.onwaiting = function() { loading.style.display = 'flex'; };
                video.onerror = function() {
                    loading.style.display = 'none';
                    errorDiv.style.display = 'block';
                    video.style.display = 'none';
                    const err = video.error;
                    document.getElementById('player-error-msg').textContent =
                        'Playback error: ' + (err ? err.message || 'Code ' + err.code : 'Unknown error');
                };

                if (strategy === 'transcode' && contentType === 'live') {
                    // Live: server-side transcode ‚Üí MPEG-TS ‚Üí mpegts.js
                    initTranscodedLivePlayer(video, streamUrl);
                } else if (strategy === 'transcode') {
                    // VOD/series transcode ‚Üí fMP4 ‚Üí native <video>
                    initNativePlayer(video, streamUrl);
                    // Show custom seek bar if we know the duration
                    if (_playerDuration > 0) showVodSeekBar(video);
                } else if (strategy === 'hls') {
                    initHlsPlayer(video, streamUrl);
                } else {
                    // native or remux
                    initNativePlayer(video, streamUrl);
                }

                // Load EPG for live channels
                _playerEpgChannelId = info.epg_channel_id || null;
                if (_playerEpgChannelId && contentType === 'live') {
                    loadPlayerEpg(_playerEpgChannelId);
                    _playerEpgInterval = setInterval(() => loadPlayerEpg(_playerEpgChannelId), 30000);
                    document.getElementById('player-epg').classList.add('visible');
                } else {
                    document.getElementById('player-epg').classList.remove('visible');
                }

            } catch (e) {
                console.error('Player error:', e);
                loading.style.display = 'none';
                errorDiv.style.display = 'block';
                video.style.display = 'none';
                document.getElementById('player-error-msg').textContent = 'Failed to start playback: ' + e.message;
            }
        }

        // Safe play ‚Äî handles Chrome autoplay restrictions by retrying muted
        function safePlay(video) {
            const playPromise = video.play();
            if (playPromise !== undefined) {
                playPromise.catch(err => {
                    console.warn('play() rejected:', err.name, err.message);
                    if (err.name === 'AbortError' || err.name === 'NotAllowedError') {
                        // Retry muted (Chrome allows muted autoplay)
                        video.muted = true;
                        video.play().then(() => {
                            showToast('Playback started muted ‚Äî click üîä to unmute', 'info');
                        }).catch(() => {});
                    }
                });
            }
        }

        /**
         * Play a live stream via server-side ffmpeg transcode + mpegts.js.
         * ffmpeg always outputs clean H.264+AAC MPEG-TS regardless of the
         * source codec (HEVC, interlaced, E-AC3, DTS ‚Äî all handled).
         */
        function initTranscodedLivePlayer(video, url) {
            if (typeof mpegts === 'undefined' || !mpegts.isSupported()) {
                console.warn('mpegts.js not supported, falling back to native');
                initNativePlayer(video, url);
                return;
            }
            const absoluteUrl = url.startsWith('/') ? window.location.origin + url : url;
            const player = mpegts.createPlayer({
                type: 'mpegts',
                isLive: true,
                url: absoluteUrl,
            }, {
                enableWorker: true,
                lazyLoad: false,
                liveBufferLatencyChasing: true,
                liveBufferLatencyMaxLatency: 8.0,
                liveBufferLatencyMinRemain: 1.5,
                stashInitialSize: 384 * 1024,
            });
            player.attachMediaElement(video);
            player.load();
            safePlay(video);

            player.on(mpegts.Events.ERROR, function(type, detail) {
                console.error('mpegts error:', type, detail);
                const errorMsg = String(detail?.msg || detail || '');
                if (type === mpegts.ErrorTypes.NETWORK_ERROR || type === mpegts.ErrorTypes.MEDIA_ERROR) {
                    document.getElementById('player-loading').style.display = 'none';
                    document.getElementById('player-error').style.display = 'block';
                    document.getElementById('player-error-msg').textContent =
                        'Stream error: ' + (errorMsg || type) + '. Try Copy URL ‚Üí VLC.';
                }
            });
            _playerInstance = player;
        }

        function initHlsPlayer(video, url) {
            // HLS.js also uses workers ‚Äî ensure absolute URL
            const absoluteUrl = url.startsWith('/') ? window.location.origin + url : url;
            if (typeof Hls === 'undefined' || !Hls.isSupported()) {
                // Safari has native HLS support
                video.src = absoluteUrl;
                video.play().catch(() => {});
                return;
            }
            const hls = new Hls({
                maxBufferLength: 30,
                maxMaxBufferLength: 60,
            });
            hls.loadSource(absoluteUrl);
            hls.attachMedia(video);
            hls.on(Hls.Events.MANIFEST_PARSED, function() {
                safePlay(video);
            });
            hls.on(Hls.Events.ERROR, function(event, data) {
                console.error('HLS error:', data);
                if (data.fatal) {
                    document.getElementById('player-error').style.display = 'block';
                    document.getElementById('player-error-msg').textContent =
                        'HLS error: ' + data.type + ' - ' + data.details;
                }
            });
            _playerInstance = hls;
        }

        function initNativePlayer(video, url) {
            video.src = url;
            safePlay(video);
        }

        // ---- VOD Seek Bar (for transcoded streams) ----
        function _fmtTime(s) {
            s = Math.floor(s);
            const h = Math.floor(s / 3600);
            const m = Math.floor((s % 3600) / 60);
            const sec = s % 60;
            if (h > 0) return h + ':' + String(m).padStart(2, '0') + ':' + String(sec).padStart(2, '0');
            return m + ':' + String(sec).padStart(2, '0');
        }

        function showVodSeekBar(video) {
            const bar = document.getElementById('player-seekbar');
            bar.classList.add('visible');

            // Update position every 500ms
            _playerSeekBarInterval = setInterval(() => {
                const pos = _playerSeekOffset + (video.currentTime || 0);
                const dur = _playerDuration;
                const pct = dur > 0 ? Math.min(100, (pos / dur) * 100) : 0;
                document.getElementById('player-seekbar-filled').style.width = pct + '%';
                document.getElementById('player-seekbar-pos').textContent =
                    _fmtTime(pos) + ' / ' + _fmtTime(dur);
            }, 500);

            // Click-to-seek on the track
            document.getElementById('player-seekbar-track').onclick = function(e) {
                const rect = this.getBoundingClientRect();
                const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
                const targetSec = pct * _playerDuration;
                vodSeek(targetSec);
            };
        }

        function hideVodSeekBar() {
            if (_playerSeekBarInterval) { clearInterval(_playerSeekBarInterval); _playerSeekBarInterval = null; }
            document.getElementById('player-seekbar').classList.remove('visible');
        }

        function vodSeek(targetSeconds) {
            if (!_playerTranscodeBase || _playerDuration <= 0) return;
            targetSeconds = Math.max(0, Math.min(_playerDuration, targetSeconds));
            _playerSeekOffset = targetSeconds;

            const video = document.getElementById('player-video');
            const loading = document.getElementById('player-loading');
            loading.style.display = 'flex';

            // Rebuild URL with start= parameter (preserve audio track selection)
            let seekUrl = _playerTranscodeBase + '&start=' + targetSeconds.toFixed(1);
            if (_playerAudioTrack >= 0) seekUrl += '&audio_track=' + _playerAudioTrack;

            // Destroy previous player instance (if mpegts/hls)
            if (_playerInstance) {
                try {
                    if (_playerInstance.destroy) _playerInstance.destroy();
                    else if (_playerInstance.detachMedia) _playerInstance.detachMedia();
                } catch(e) {}
                _playerInstance = null;
            }

            // Restart native playback from new position
            video.src = seekUrl;
            safePlay(video);

            // Update seek bar immediately
            document.getElementById('player-seekbar-filled').style.width =
                (targetSeconds / _playerDuration * 100) + '%';
            document.getElementById('player-seekbar-pos').textContent =
                _fmtTime(targetSeconds) + ' / ' + _fmtTime(_playerDuration);
        }

        // ---- Audio Track Selector ----
        function showAudioTrackSelector(tracks, strategy) {
            const container = document.getElementById('player-audio-select');
            const sel = document.getElementById('player-audio-track');
            sel.innerHTML = '';
            if (!tracks || tracks.length <= 1) {
                container.classList.remove('visible');
                return;
            }
            tracks.forEach(function(t) {
                const opt = document.createElement('option');
                opt.value = t.index;
                let label = 'Track ' + (t.index + 1);
                if (t.language) label += ' ‚Äî ' + t.language.toUpperCase();
                if (t.title) label += ' (' + t.title + ')';
                const ch = t.channels;
                if (ch === 2) label += ' [Stereo]';
                else if (ch === 6) label += ' [5.1]';
                else if (ch === 8) label += ' [7.1]';
                else if (ch > 0) label += ' [' + ch + 'ch]';
                label += ' ¬∑ ' + (t.codec || '').toUpperCase();
                opt.textContent = label;
                sel.appendChild(opt);
            });
            sel.value = _playerAudioTrack >= 0 ? _playerAudioTrack : '0';
            container.classList.add('visible');
        }

        function hideAudioTrackSelector() {
            document.getElementById('player-audio-select').classList.remove('visible');
        }

        function switchAudioTrack(trackIndex) {
            trackIndex = parseInt(trackIndex, 10);
            if (isNaN(trackIndex) || trackIndex === _playerAudioTrack) return;
            _playerAudioTrack = trackIndex;

            const video = document.getElementById('player-video');
            const loading = document.getElementById('player-loading');
            loading.style.display = 'flex';

            // Build URL with audio_track param from base URL
            let url = _playerTranscodeBase + '&audio_track=' + trackIndex;
            if (_playerIsTranscodedVod) {
                // VOD: keep current seek position
                const currentPos = _playerSeekOffset + (video.currentTime || 0);
                if (currentPos > 2) {
                    url += '&start=' + currentPos.toFixed(1);
                    _playerSeekOffset = currentPos;
                }
            }

            // Destroy previous player instance
            if (_playerInstance) {
                try {
                    if (_playerInstance.destroy) _playerInstance.destroy();
                    else if (_playerInstance.detachMedia) _playerInstance.detachMedia();
                } catch(e) {}
                _playerInstance = null;
            }

            if (_playerIsTranscodedVod) {
                // VOD: native <video> with fMP4
                video.src = url;
                safePlay(video);
            } else {
                // Live: mpegts.js with MPEG-TS
                initTranscodedLivePlayer(video, url);
            }
        }

        function destroyPlayerInstance() {
            const video = document.getElementById('player-video');
            if (_playerInstance) {
                try {
                    if (_playerInstance.destroy) _playerInstance.destroy();   // mpegts
                    else if (_playerInstance.detachMedia) _playerInstance.detachMedia(); // hls
                } catch(e) { console.warn('Player cleanup:', e); }
                _playerInstance = null;
            }
            video.removeAttribute('src');
            video.load(); // Reset
            hideVodSeekBar();
            hideAudioTrackSelector();
        }

        function closePlayer() {
            destroyPlayerInstance();
            document.getElementById('player-modal').classList.remove('show');
            if (_playerEpgInterval) { clearInterval(_playerEpgInterval); _playerEpgInterval = null; }
            _playerEpgChannelId = null;
            _playerStreamUrl = '';
            _playerIsTranscodedVod = false;
            _playerDuration = 0;
            _playerSeekOffset = 0;
            _playerAudioTrack = -1;
            _playerAudioTracks = [];
        }

        function copyStreamUrl() {
            const url = window.location.origin + _playerStreamUrl;
            navigator.clipboard.writeText(url).then(() => {
                showToast('Stream URL copied to clipboard', 'success');
            }).catch(() => {
                // Fallback
                prompt('Copy this URL:', url);
            });
        }

        function openInVlc() {
            const url = window.location.origin + _playerStreamUrl;
            window.open('vlc://' + url, '_blank');
        }

        // EPG now/next
        async function loadPlayerEpg(channelId) {
            try {
                const resp = await fetch('/api/player/epg/now/' + encodeURIComponent(channelId));
                if (!resp.ok) return;
                const data = await resp.json();

                const epgDiv = document.getElementById('player-epg');
                if (data.current) {
                    document.getElementById('player-epg-current-title').textContent = data.current.title || '';
                    const startTime = data.current.start ? new Date(data.current.start * 1000).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) : '';
                    const stopTime = data.current.stop ? new Date(data.current.stop * 1000).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) : '';
                    document.getElementById('player-epg-current-time').textContent = startTime + (stopTime ? ' - ' + stopTime : '');
                    document.getElementById('player-epg-progress-bar').style.width = (data.current.progress_pct || 0) + '%';
                    epgDiv.classList.add('visible');
                } else {
                    document.getElementById('player-epg-current-title').textContent = '';
                    document.getElementById('player-epg-current-time').textContent = '';
                    document.getElementById('player-epg-progress-bar').style.width = '0%';
                }

                if (data.next) {
                    document.getElementById('player-epg-next-title').textContent = data.next.title || '';
                    const nextTime = data.next.start ? new Date(data.next.start * 1000).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) : '';
                    document.getElementById('player-epg-next-time').textContent = nextTime;
                } else {
                    document.getElementById('player-epg-next-title').textContent = '';
                    document.getElementById('player-epg-next-time').textContent = '';
                }
            } catch(e) { /* ignore EPG errors */ }
        }

        // Keyboard shortcuts for player
        document.addEventListener('keydown', function(e) {
            const modal = document.getElementById('player-modal');
            if (!modal.classList.contains('show')) return;
            const video = document.getElementById('player-video');

            switch(e.key) {
                case 'Escape':
                    closePlayer();
                    e.preventDefault();
                    break;
                case ' ':
                    if (video.paused) video.play().catch(()=>{});
                    else video.pause();
                    e.preventDefault();
                    break;
                case 'f':
                case 'F':
                    if (document.fullscreenElement) document.exitFullscreen();
                    else document.getElementById('player-video-wrap').requestFullscreen().catch(()=>{});
                    e.preventDefault();
                    break;
                case 'm':
                case 'M':
                    video.muted = !video.muted;
                    e.preventDefault();
                    break;
                case 'ArrowLeft':
                    if (_playerIsTranscodedVod && _playerDuration > 0) {
                        vodSeek(Math.max(0, (_playerSeekOffset + video.currentTime) - 15));
                    } else if (video.duration && isFinite(video.duration)) {
                        video.currentTime = Math.max(0, video.currentTime - 10);
                    }
                    e.preventDefault();
                    break;
                case 'ArrowRight':
                    if (_playerIsTranscodedVod && _playerDuration > 0) {
                        vodSeek(Math.min(_playerDuration, (_playerSeekOffset + video.currentTime) + 15));
                    } else if (video.duration && isFinite(video.duration)) {
                        video.currentTime = Math.min(video.duration, video.currentTime + 10);
                    }
                    e.preventDefault();
                    break;
            }
        });

        // Double-click to fullscreen
        document.getElementById('player-video-wrap').addEventListener('dblclick', function() {
            if (document.fullscreenElement) document.exitFullscreen();
            else this.requestFullscreen().catch(()=>{});
        });

        let contentType = 'live';
        let currentPage = 1;
        let totalPages = 1;
        let searchTimeout = null;
        let sources = [];
        let categories = [];
        let selectedCategoryId = null;
        let currentFetchController = null; // AbortController for cancelling in-flight requests

        const iconMap = {
            'folder': 'üìÅ', 'heart': '‚ù§Ô∏è', 'star': '‚≠ê', 'film': 'üé¨', 'tv': 'üì∫',
            'game': 'üéÆ', 'music': 'üéµ', 'sport': 'üèÄ', 'fire': 'üî•', 'bookmark': 'üîñ'
        };

        document.addEventListener('DOMContentLoaded', function() {
            loadSources();
            loadCategories();
            // Show initial state without auto-loading results
            document.getElementById('loading-state').style.display = 'none';
            renderBrowseNav();
            document.getElementById('empty-state').innerHTML = '<p>Use the filters above and click <strong>Search</strong> to find content.</p>';
            document.getElementById('empty-state').style.display = 'block';
            document.querySelectorAll('.icon-option').forEach(opt => {
                opt.addEventListener('click', function() {
                    document.querySelectorAll('.icon-option').forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                });
            });
            document.addEventListener('click', function(e) {
                document.querySelectorAll('.category-dropdown.show').forEach(d => d.classList.remove('show'));
            });
        });

        async function loadSources() {
            try {
                const response = await fetch('/api/sources');
                const data = await response.json();
                sources = data.sources || [];
                const sourceFilter = document.getElementById('source-filter');
                sourceFilter.innerHTML = '<option value="">All Sources</option>';
                sources.forEach((source, index) => {
                    const option = document.createElement('option');
                    option.value = source.id;
                    option.textContent = source.name;
                    sourceFilter.appendChild(option);
                });
            } catch (error) { console.error('Error loading sources:', error); }
        }

        async function loadCategories() {
            try {
                const response = await fetch('/api/categories');
                const data = await response.json();
                categories = data.categories || [];
                renderBrowseNav();
            } catch (error) { console.error('Error loading categories:', error); }
        }

        async function refreshCategories() {
            const btn = document.getElementById('refresh-cats-btn');
            if (btn) btn.classList.add('refreshing');
            try {
                await fetch('/api/categories/refresh', { method: 'POST' });
                await loadCategories();
                if (selectedCategoryId) applyFilters();
            } catch (error) {
                console.error('Error refreshing categories:', error);
            } finally {
                const b = document.getElementById('refresh-cats-btn');
                if (b) b.classList.remove('refreshing');
            }
        }

        function renderBrowseNav() {
            const container = document.getElementById('browse-nav');
            const allActive = selectedCategoryId === null ? 'active' : '';
            let html = '<div class="category-pill ' + allActive + '" onclick="selectScope(null)"><span>üìã</span><span>All Content</span></div>';
            if (categories.length > 0) {
                html += '<div class="browse-nav-separator"></div>';
            }
            html += categories.map(cat => {
                const rawItems = cat.mode === 'automatic' ? (cat.cached_items || []) : (cat.items || []);
                const count = rawItems.length;
                const icon = iconMap[cat.icon] || cat.icon || 'üìÅ';
                const isActive = selectedCategoryId === cat.id ? 'active' : '';
                const modeIndicator = cat.mode === 'automatic' ? ' ü§ñ' : '';
                return '<div class="category-pill ' + isActive + '" onclick="selectScope(\'' + cat.id + '\')">'
                    + '<span>' + icon + '</span><span>' + cat.name + modeIndicator + '</span>'
                    + '<span class="cat-count">' + count + '</span></div>';
            }).join('');
            html += '<div class="browse-nav-actions">';
            html += '<button id="refresh-cats-btn" class="btn btn-secondary btn-small btn-icon" onclick="refreshCategories()" title="Refresh automatic categories">üîÑ</button>';
            html += '<button class="btn btn-primary btn-small" onclick="openCategoryModal()">+ New</button>';
            html += '<button class="btn btn-secondary btn-small" onclick="openManageCategoriesModal()">Manage</button>';
            html += '</div>';
            container.innerHTML = html;
        }

        function selectScope(categoryId) {
            if (categoryId !== null && selectedCategoryId === categoryId) {
                selectedCategoryId = null;
            } else {
                selectedCategoryId = categoryId;
            }
            // Hide main controls row in category view, but keep sort/filter visible
            document.querySelector('#controls-bar > .controls-row:first-child').style.display = selectedCategoryId ? 'none' : 'flex';
            document.getElementById('sort-filter-row').style.display = selectedCategoryId ? 'flex' : ((contentType === 'vod' || contentType === 'series') ? 'flex' : 'none');
            document.getElementById('controls-bar').style.display = 'block';
            renderBrowseNav();
            currentPage = 1;
            applyFilters();
        }

        function setContentType(type) {
            contentType = type;
            document.querySelectorAll('.type-pill').forEach(pill => {
                pill.classList.toggle('active', pill.dataset.type === type);
            });
            // Show sort/filter row for vod and series only
            const sortFilterRow = document.getElementById('sort-filter-row');
            sortFilterRow.style.display = (type === 'vod' || type === 'series') ? 'flex' : 'none';
            currentPage = 1;
            // Don't auto-search - user will click Search button
        }

        async function loadGroups() {
            // Groups are loaded from browse API response instead
            // This function is kept for compatibility but does nothing
            // Groups will be populated by applyFilters
        }

        function debounceSearch() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => { currentPage = 1; applyFilters(); }, 300);
        }

        async function applyFilters() {
            // Cancel any in-flight request
            if (currentFetchController) {
                currentFetchController.abort();
            }
            currentFetchController = new AbortController();
            const signal = currentFetchController.signal;

            const searchQuery = document.getElementById('search-input').value;
            const sourceId = document.getElementById('source-filter').value;
            const group = document.getElementById('group-filter').value;
            const useSourceFilters = document.getElementById('use-source-filters-browse').checked;
            const loadingState = document.getElementById('loading-state');
            const emptyState = document.getElementById('empty-state');
            const contentGrid = document.getElementById('content-grid');
            const pagination = document.getElementById('pagination');

            loadingState.style.display = 'block';
            emptyState.style.display = 'none';
            contentGrid.innerHTML = '';
            pagination.style.display = 'none';

            try {
                const sortBy = document.getElementById('sort-by').value;
                const sortOrder = document.getElementById('sort-order').value;
                const minRating = document.getElementById('min-rating').value;
                const maxAddedDays = document.getElementById('max-added-days').value;

                let url;
                if (selectedCategoryId) {
                    // Category view: don't send type ‚Äî API returns all types
                    url = '/api/browse?page=' + currentPage + '&per_page=50&category_id=' + selectedCategoryId;
                } else {
                    url = '/api/browse?type=' + contentType + '&page=' + currentPage + '&per_page=50';
                    if (searchQuery) url += '&search=' + encodeURIComponent(searchQuery);
                    if (sourceId) url += '&source=' + sourceId;
                    if (group) url += '&group=' + encodeURIComponent(group);
                    if (useSourceFilters) url += '&use_source_filters=true';
                }
                if (sortBy) url += '&sort_by=' + sortBy;
                if (sortOrder !== 'desc') url += '&sort_order=' + sortOrder;
                if (minRating !== '0') url += '&min_rating=' + minRating;
                if (maxAddedDays !== '0') url += '&max_added_days=' + maxAddedDays;

                const response = await fetch(url, { signal });
                const data = await response.json();

                loadingState.style.display = 'none';
                document.getElementById('showing-count').textContent = data.items.length;
                document.getElementById('total-count').textContent = data.total;

                // Populate groups dropdown from API response
                if (data.groups && data.groups.length > 0) {
                    const groupFilter = document.getElementById('group-filter');
                    const currentValue = groupFilter.value;
                    groupFilter.innerHTML = '<option value="">All Groups</option>';
                    data.groups.forEach(g => {
                        const option = document.createElement('option');
                        option.value = g.name;
                        option.textContent = g.name + ' (' + g.count + ')';
                        groupFilter.appendChild(option);
                    });
                    if (data.groups.some(g => g.name === currentValue)) groupFilter.value = currentValue;
                }

                if (data.items.length === 0) {
                    emptyState.style.display = 'block';
                    return;
                }

                totalPages = data.total_pages;
                currentPage = data.page;
                renderContent(data.items, data.grouped);
                updatePagination();
            } catch (error) {
                // Ignore aborted requests (user clicked another category)
                if (error.name === 'AbortError') {
                    return;
                }
                console.error('Error fetching content:', error);
                loadingState.style.display = 'none';
                emptyState.style.display = 'block';
            }
        }

        function renderContent(items, grouped) {
            const grid = document.getElementById('content-grid');
            grid.innerHTML = items.map((item, idx) => {
                if (grouped && item.count > 1) {
                    return renderGroupedCard(item, idx);
                }
                // Single item (or non-grouped mode)
                const single = (grouped && item.items) ? item.items[0] : item;
                return renderSingleCard(single);
            }).join('');
        }

        const typeLabels = { live: 'Live', vod: 'Film', series: 'Series' };
        function typeBadgeHtml(ct) {
            if (!ct) return '';
            return '<span class="type-badge type-badge-' + ct + '">' + (typeLabels[ct] || ct) + '</span>';
        }

        function renderSingleCard(item) {
            const itemType = item.content_type || contentType;
            const posterClass = itemType === 'live' ? 'card-poster-placeholder live' : 'card-poster-placeholder';
            const poster = item.icon;
            const placeholderIcon = itemType === 'live' ? 'üì°' : 'üé¨';
            const imgClass = 'card-poster' + (itemType === 'live' ? ' card-poster-live' : '');
            const posterHtml = poster
                ? '<img class="' + imgClass + '" src="' + poster + '" loading="lazy" onerror="this.style.display=\'none\';this.nextSibling.style.display=\'flex\'"><div class="' + posterClass + '" style="display:none">' + placeholderIcon + '</div>'
                : '<div class="' + posterClass + '">' + placeholderIcon + '</div>';
            const sourceIndex = sources.findIndex(s => s.id === item.source_id) + 1;
            const sourceName = item.source_name || 'Unknown';
            const isNew = item.added && isRecent(item.added, 7);
            const itemCategories = getItemCategories(item);
            const hasCats = itemCategories.length > 0;
            const inCategoryView = !!selectedCategoryId;

            let catBadges = '';
            if (itemCategories.length > 0) {
                catBadges = '<div class="card-categories">' + itemCategories.slice(0, 3).map(c => '<span class="card-cat-badge">' + (iconMap[c.icon] || c.icon) + ' ' + c.name + '</span>').join('') + '</div>';
            }

            const cartBtn = (itemType === 'vod' || itemType === 'series')
                ? '<button class="add-cart-btn" data-source-id="' + escapeAttr(item.source_id) + '" data-item-id="' + escapeAttr(item.id) + '" data-content-type="' + escapeAttr(itemType) + '" data-name="' + escapeAttr(item.name) + '" data-icon="' + escapeAttr(item.icon || '') + '" data-group="' + escapeAttr(item.group || '') + '" data-ext="' + escapeAttr(item.container_extension || 'mp4') + '" title="Add to download cart">üõí</button>'
                : '';

            const monitorBtn = (itemType === 'series')
                ? '<button class="add-monitor-btn" onclick="openMonitorModal(event, \'' + escapeAttr(item.source_id) + '\', \'' + escapeAttr(item.id) + '\', \'' + jsEscape(item.name) + '\', \'' + escapeAttr(item.icon || '') + '\', \'' + escapeAttr(item.source_name || '') + '\')" title="Monitor this series">üì°</button>'
                : '';

            const playExt = item.container_extension || (itemType === 'live' ? 'ts' : 'mp4');
            const playBtn = (itemType === 'series')
                ? '<button class="play-btn" onclick="event.stopPropagation(); _handleCartAdd(\'' + escapeAttr(item.source_id) + '\', \'' + escapeAttr(item.id) + '\', \'series\', \'' + jsEscape(item.name) + '\', \'' + escapeAttr(item.icon || '') + '\', \'' + escapeAttr(item.group || '') + '\', null, \'' + escapeAttr(playExt) + '\')" title="Browse episodes">‚ñ∂</button>'
                : (itemType !== 'series'
                    ? '<button class="play-btn" onclick="event.stopPropagation(); openPlayer(\'' + escapeAttr(itemType) + '\', \'' + escapeAttr(item.source_id) + '\', \'' + escapeAttr(item.id) + '\', \'' + jsEscape(item.name) + '\', \'' + escapeAttr(item.icon || '') + '\', \'' + escapeAttr(item.group || '') + '\', \'' + escapeAttr(playExt) + '\')" title="Play in browser">‚ñ∂</button>'
                    : '');

            return '<div class="content-card" ' + (itemType === 'series' ? 'onclick="_handleCartAdd(\'' + escapeAttr(item.source_id) + '\', \'' + escapeAttr(item.id) + '\', \'series\', \'' + jsEscape(item.name) + '\', \'' + escapeAttr(item.icon || '') + '\', \'' + escapeAttr(item.group || '') + '\', null, \'' + escapeAttr(playExt) + '\')" style="cursor:pointer"' : '') + '>' +
                (isNew ? '<div class="new-badge">NEW</div>' : '') +
                cartBtn +
                monitorBtn +
                '<button class="add-category-btn' + (hasCats ? ' has-categories' : '') + '" onclick="toggleCategoryDropdown(event, \'' + item.source_id + '\', \'' + item.id + '\', \'' + itemType + '\')">+</button>' +
                '<div class="category-dropdown" id="cat-dropdown-' + item.source_id + '-' + item.id + '"></div>' +
                playBtn +
                posterHtml +
                '<div class="card-info">' +
                '<div class="card-title">' + escapeHtml(item.name) + (inCategoryView ? typeBadgeHtml(itemType) : '') + '</div>' +
                '<div class="card-meta">' +
                '<span class="source-badge" data-color="' + (sourceIndex % 5 || 5) + '">' + escapeHtml(sourceName) + '</span>' +
                (item.group ? '<span class="card-group">' + escapeHtml(item.group) + '</span>' : '') +
                (item.rating ? '<span class="card-rating"><span class="star">‚òÖ</span> ' + item.rating.toFixed(1) + '</span>' : '') +
                '</div>' +
                catBadges +
                (item.added ? '<div class="card-date">Added: ' + formatDate(item.added) + '</div>' : '') +
                '</div></div>';
        }

        function renderGroupedCard(group, idx) {
            // Determine dominant content type from sub-items
            const groupType = group.items[0]?.content_type || contentType;
            const inCategoryView = !!selectedCategoryId;
            const posterClass = groupType === 'live' ? 'card-poster-placeholder live' : 'card-poster-placeholder';
            const poster = group.icon;
            const placeholderIcon = groupType === 'live' ? 'üì°' : 'üé¨';
            const imgClass = 'card-poster' + (groupType === 'live' ? ' card-poster-live' : '');
            const posterHtml = poster
                ? '<img class="' + imgClass + '" src="' + poster + '" loading="lazy" onerror="this.style.display=\'none\';this.nextSibling.style.display=\'flex\'"><div class="' + posterClass + '" style="display:none">' + placeholderIcon + '</div>'
                : '<div class="' + posterClass + '">' + placeholderIcon + '</div>';

            // Collect categories from all sub-items (deduplicated)
            const allCatIds = new Set();
            const allCats = [];
            group.items.forEach(sub => {
                getItemCategories(sub).forEach(c => {
                    if (!allCatIds.has(c.id)) { allCatIds.add(c.id); allCats.push(c); }
                });
            });
            let catBadges = '';
            if (allCats.length > 0) {
                catBadges = '<div class="card-categories">' + allCats.slice(0, 3).map(c => '<span class="card-cat-badge">' + (iconMap[c.icon] || c.icon) + ' ' + c.name + '</span>').join('') + '</div>';
            }

            // Check if any sub-item is new
            const isNew = group.items.some(sub => sub.added && isRecent(sub.added, 7));

            // Build top-level cart button for grouped series cards with all sources encoded
            let groupCartBtn = '';
            if (groupType === 'series' || groupType === 'vod') {
                const allSourcesData = group.items.map(sub => ({
                    source_id: sub.source_id,
                    source_name: sub.source_name || 'Unknown',
                    item_id: sub.id,
                    name: sub.name,
                    icon: sub.icon || sub.cover || '',
                    group: sub.group || '',
                    container_extension: sub.container_extension || 'mp4'
                }));
                groupCartBtn = '<button class="add-cart-btn" data-source-id="' + escapeAttr(group.items[0].source_id) + '" data-item-id="' + escapeAttr(group.items[0].id) + '" data-content-type="' + escapeAttr(groupType) + '" data-name="' + escapeAttr(group.name) + '" data-icon="' + escapeAttr(group.icon || '') + '" data-group="' + escapeAttr(group.items[0].group || '') + '" data-ext="' + escapeAttr(group.items[0].container_extension || 'mp4') + '" data-all-sources="' + escapeAttr(JSON.stringify(allSourcesData)) + '" title="Add to download cart">üõí</button>';
            }

            // Monitor button for grouped series cards
            let groupMonitorBtn = '';
            if (groupType === 'series') {
                // Build all-sources data for monitor modal (deduplicated by source_id+series_id)
                const seenSourceSeries = new Set();
                const monitorSourcesData = [];
                for (const sub of group.items) {
                    const key = sub.source_id + '|' + sub.id;
                    if (!seenSourceSeries.has(key)) {
                        seenSourceSeries.add(key);
                        monitorSourcesData.push({
                            source_id: sub.source_id,
                            source_name: sub.source_name || 'Unknown',
                            series_id: sub.id,
                            category: sub.group || '',
                        });
                    }
                }
                groupMonitorBtn = '<button class="add-monitor-btn" onclick="openMonitorModal(event, null, \'' + escapeAttr(group.items[0].id) + '\', \'' + jsEscape(group.name) + '\', \'' + escapeAttr(group.icon || '') + '\', null, ' + escapeAttr(JSON.stringify(monitorSourcesData)) + ')" title="Monitor this series">üì°</button>';
            }

            // Build source rows for expand area
            const sourceRows = group.items.map(sub => {
                const si = sources.findIndex(s => s.id === sub.source_id) + 1;
                const sName = sub.source_name || 'Unknown';
                const subCats = getItemCategories(sub);
                const subHasCats = subCats.length > 0;
                const subType = sub.content_type || groupType;
                const subPlayExt = sub.container_extension || (subType === 'live' ? 'ts' : 'mp4');
                const subPlayBtn = (subType === 'series')
                    ? '<button class="episode-play-btn" onclick="event.stopPropagation(); openEpisodeModal(\'' + escapeAttr(sub.source_id) + '\', \'' + escapeAttr(sub.id) + '\', \'' + jsEscape(sub.name) + '\', \'' + escapeAttr(sub.icon || '') + '\', \'' + escapeAttr(sub.group || '') + '\')" title="Browse episodes">‚ñ∂</button>'
                    : '<button class="episode-play-btn" onclick="event.stopPropagation(); openPlayer(\'' + escapeAttr(subType) + '\', \'' + escapeAttr(sub.source_id) + '\', \'' + escapeAttr(sub.id) + '\', \'' + jsEscape(sub.name) + '\', \'' + escapeAttr(sub.icon || '') + '\', \'' + escapeAttr(sub.group || '') + '\', \'' + escapeAttr(subPlayExt) + '\')" title="Play">‚ñ∂</button>';
                return '<div class="source-row">' +
                    '<div class="source-row-name">' + subPlayBtn + ' ' + escapeHtml(sub.name) + '</div>' +
                    '<div class="source-row-meta">' +
                    '<span class="source-badge" data-color="' + (si % 5 || 5) + '">' + escapeHtml(sName) + '</span>' +
                    (sub.group ? '<span class="source-row-group">' + escapeHtml(sub.group) + '</span>' : '') +
                    '<span class="source-row-actions">' +
                    '<button class="source-row-cat-btn' + (subHasCats ? ' has-categories' : '') + '" onclick="toggleCategoryDropdown(event, \'' + sub.source_id + '\', \'' + sub.id + '\', \'' + (sub.content_type || groupType) + '\')">+</button>' +
                    '<div class="category-dropdown" id="cat-dropdown-' + sub.source_id + '-' + sub.id + '" style="position:relative;top:0;right:0;"></div>' +
                    '</span>' +
                    '</div>' +
                    '</div>';
            }).join('');

            const groupId = 'group-' + idx;

            // Play button for grouped card (uses first item)
            const firstItem = group.items[0];
            const groupPlayExt = firstItem.container_extension || (groupType === 'live' ? 'ts' : 'mp4');
            // For series, build allSources JSON for the episode modal source selector
            let groupPlayBtn;
            if (groupType === 'series') {
                const playSources = group.items.map(sub => ({
                    source_id: sub.source_id,
                    source_name: sub.source_name || 'Unknown',
                    item_id: sub.id,
                    name: sub.name,
                    icon: sub.icon || sub.cover || '',
                    group: sub.group || '',
                }));
                const playSourcesJson = JSON.stringify(playSources);
                groupPlayBtn = '<button class="play-btn" onclick="event.stopPropagation(); openEpisodeModal(\'' + escapeAttr(firstItem.source_id) + '\', \'' + escapeAttr(firstItem.id) + '\', \'' + jsEscape(group.name) + '\', \'' + escapeAttr(group.icon || '') + '\', \'' + escapeAttr(firstItem.group || '') + '\', ' + escapeAttr(playSourcesJson) + ')" title="Browse episodes">‚ñ∂</button>';
            } else {
                groupPlayBtn = '<button class="play-btn" onclick="event.stopPropagation(); openPlayer(\'' + escapeAttr(groupType) + '\', \'' + escapeAttr(firstItem.source_id) + '\', \'' + escapeAttr(firstItem.id) + '\', \'' + jsEscape(group.name) + '\', \'' + escapeAttr(group.icon || '') + '\', \'' + escapeAttr(firstItem.group || '') + '\', \'' + escapeAttr(groupPlayExt) + '\')" title="Play in browser">‚ñ∂</button>';
            }

            return '<div class="content-card">' +
                (isNew ? '<div class="new-badge">NEW</div>' : '') +
                groupCartBtn +
                groupMonitorBtn +
                groupPlayBtn +
                posterHtml +
                '<div class="card-info">' +
                '<div class="card-title">' + escapeHtml(group.name) + (inCategoryView ? typeBadgeHtml(groupType) : '') +
                '<span class="sources-badge">' + group.count + ' sources</span>' +
                '</div>' +
                '<div class="card-meta">' +
                (group.rating ? '<span class="card-rating"><span class="star">‚òÖ</span> ' + group.rating.toFixed(1) + '</span>' : '') +
                '</div>' +
                catBadges +
                (group.added ? '<div class="card-date">Added: ' + formatDate(group.added) + '</div>' : '') +
                '</div>' +
                '<div class="sources-toggle" onclick="toggleSourcesList(this, \'' + groupId + '\')">' +
                '<span class="arrow">‚ñº</span> Show ' + group.count + ' sources' +
                '</div>' +
                '<div class="sources-list" id="' + groupId + '">' +
                sourceRows +
                '</div>' +
                '</div>';
        }

        function toggleSourcesList(toggleEl, groupId) {
            const list = document.getElementById(groupId);
            const isOpen = list.classList.contains('show');
            list.classList.toggle('show');
            toggleEl.classList.toggle('expanded');
            toggleEl.querySelector('.arrow').textContent = isOpen ? '‚ñº' : '‚ñ≤';
            const label = isOpen ? 'Show' : 'Hide';
            const count = list.querySelectorAll('.source-row').length;
            toggleEl.innerHTML = '<span class="arrow">' + (isOpen ? '‚ñº' : '‚ñ≤') + '</span> ' + label + ' ' + count + ' sources';
        }

        function getItemCategories(item) {
            const itemType = item.content_type || contentType;
            return categories.filter(cat => {
                if (cat.mode === 'manual') {
                    return (cat.items || []).some(i => i.source_id === item.source_id && String(i.id) === String(item.id) && i.content_type === itemType);
                } else {
                    return (cat.cached_items || []).some(i => i.source_id === item.source_id && String(i.id) === String(item.id) && i.content_type === itemType);
                }
            });
        }

        function toggleCategoryDropdown(event, sourceId, itemId, cType) {
            event.stopPropagation();
            document.querySelectorAll('.category-dropdown.show').forEach(d => d.classList.remove('show'));
            const dropdown = document.getElementById('cat-dropdown-' + sourceId + '-' + itemId);
            const itemCats = categories.filter(cat => {
                const items = cat.mode === 'manual' ? cat.items : cat.cached_items;
                return (items || []).some(i => i.source_id === sourceId && String(i.id) === String(itemId) && i.content_type === cType);
            });

            dropdown.innerHTML = categories.filter(c => c.mode === 'manual').map(cat => {
                const isIn = itemCats.some(ic => ic.id === cat.id);
                const icon = iconMap[cat.icon] || cat.icon || 'üìÅ';
                return '<div class="category-dropdown-item' + (isIn ? ' in-category' : '') + '" onclick="toggleItemInCategory(event, \'' + cat.id + '\', \'' + sourceId + '\', \'' + itemId + '\', \'' + cType + '\')">' +
                    '<span class="cat-check">' + (isIn ? '‚úì' : '') + '</span>' +
                    '<span>' + icon + ' ' + escapeHtml(cat.name) + '</span></div>';
            }).join('') || '<div class="category-dropdown-item" style="color:#666">No manual categories</div>';

            dropdown.classList.add('show');
        }

        async function toggleItemInCategory(event, categoryId, sourceId, itemId, cType) {
            event.stopPropagation();
            const cat = categories.find(c => c.id === categoryId);
            const isIn = (cat.items || []).some(i => i.source_id === sourceId && String(i.id) === String(itemId) && i.content_type === cType);

            try {
                if (isIn) {
                    await fetch('/api/categories/' + categoryId + '/items/' + cType + '/' + sourceId + '/' + itemId, { method: 'DELETE' });
                    showToast('Removed from ' + cat.name, 'info');
                } else {
                    await fetch('/api/categories/' + categoryId + '/items', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ source_id: sourceId, id: String(itemId), content_type: cType })
                    });
                    showToast('Added to ' + cat.name, 'success');
                }
                await loadCategories();
                // Update the + button style and dropdown for this item without reloading results
                updateItemCategoryUI(sourceId, itemId, cType);
            } catch (error) { 
                console.error('Error toggling item in category:', error);
                showToast('Error updating category', 'error');
            }
        }

        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = 'toast toast-' + type;
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.classList.add('show'), 10);
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, 2000);
        }

        function updateItemCategoryUI(sourceId, itemId, cType) {
            // Check if item is in any category
            const hasCats = categories.some(cat => {
                const items = cat.mode === 'manual' ? cat.items : cat.cached_items;
                return (items || []).some(i => i.source_id === sourceId && String(i.id) === String(itemId) && i.content_type === cType);
            });
            
            // Update the + button style
            const card = document.querySelector('.content-card button[onclick*="' + sourceId + '"][onclick*="' + itemId + '"]');
            if (card) {
                card.classList.toggle('has-categories', hasCats);
            }
            
            // Refresh the dropdown content
            const dropdown = document.getElementById('cat-dropdown-' + sourceId + '-' + itemId);
            if (dropdown && dropdown.classList.contains('show')) {
                const itemCats = categories.filter(cat => {
                    const items = cat.mode === 'manual' ? cat.items : cat.cached_items;
                    return (items || []).some(i => i.source_id === sourceId && i.item_id === String(itemId) && i.content_type === cType);
                });
                dropdown.innerHTML = categories.filter(c => c.mode === 'manual').map(cat => {
                    const isIn = itemCats.some(ic => ic.id === cat.id);
                    const icon = iconMap[cat.icon] || cat.icon || 'üìÅ';
                    return '<div class="category-dropdown-item' + (isIn ? ' in-category' : '') + '" onclick="toggleItemInCategory(event, \'' + cat.id + '\', \'' + sourceId + '\', \'' + itemId + '\', \'' + cType + '\')">' +
                        '<span class="cat-check">' + (isIn ? '‚úì' : '') + '</span>' +
                        '<span>' + icon + ' ' + escapeHtml(cat.name) + '</span></div>';
                }).join('') || '<div class="category-dropdown-item" style="color:#666">No manual categories</div>';
            }
        }

        function openCategoryModal(categoryId = null) {
            const modal = document.getElementById('category-modal');
            const title = document.getElementById('category-modal-title');
            document.getElementById('category-edit-id').value = categoryId || '';
            title.textContent = categoryId ? 'Edit Category' : 'Create Category';

            if (categoryId) {
                const cat = categories.find(c => c.id === categoryId);
                if (cat) {
                    document.getElementById('category-name').value = cat.name;
                    document.querySelectorAll('.icon-option').forEach(o => {
                        o.classList.toggle('selected', o.dataset.icon === cat.icon);
                    });
                    selectMode(cat.mode);
                    document.querySelectorAll('.content-type-checkbox').forEach(cb => {
                        const isSelected = (cat.content_types || []).includes(cb.dataset.type);
                        cb.classList.toggle('selected', isSelected);
                    });
                    document.getElementById('pattern-logic').value = cat.pattern_logic || 'or';
                    document.getElementById('use-source-filters').checked = cat.use_source_filters || false;
                    document.getElementById('notify-telegram').checked = cat.notify_telegram || false;
                    // Handle recently added filter
                    const recentlyAddedDays = cat.recently_added_days || 0;
                    document.getElementById('use-recently-added').checked = recentlyAddedDays > 0;
                    document.getElementById('recently-added-days').value = recentlyAddedDays > 0 ? recentlyAddedDays : '7';
                    document.getElementById('recently-added-days').disabled = recentlyAddedDays === 0;
                    renderPatterns(cat.patterns || []);
                }
            } else {
                document.getElementById('category-name').value = '';
                document.querySelectorAll('.icon-option').forEach((o, i) => o.classList.toggle('selected', i === 0));
                selectMode('manual');
                document.querySelectorAll('.content-type-checkbox').forEach(cb => {
                    cb.classList.add('selected');
                });
                document.getElementById('pattern-logic').value = 'or';
                document.getElementById('use-source-filters').checked = false;
                document.getElementById('notify-telegram').checked = false;
                document.getElementById('use-recently-added').checked = false;
                document.getElementById('recently-added-days').value = '7';
                document.getElementById('recently-added-days').disabled = true;
                renderPatterns([]);
            }
            modal.classList.add('show');
        }

        function closeCategoryModal() { document.getElementById('category-modal').classList.remove('show'); }

        function selectMode(mode) {
            document.querySelectorAll('.mode-option').forEach(o => o.classList.toggle('selected', o.dataset.mode === mode));
            document.getElementById('patterns-section').classList.toggle('show', mode === 'automatic');
        }

        function toggleContentType(el) {
            el.classList.toggle('selected');
        }

        function toggleRecentlyAdded() {
            const checkbox = document.getElementById('use-recently-added');
            const select = document.getElementById('recently-added-days');
            select.disabled = !checkbox.checked;
        }

        function renderPatterns(patterns) {
            const container = document.getElementById('patterns-container');
            if (patterns.length === 0) {
                container.innerHTML = '<div class="pattern-row"><select><option value="contains">Contains</option><option value="not_contains">Does not contain</option><option value="starts_with">Starts with</option><option value="ends_with">Ends with</option><option value="exact">Exact match</option><option value="regex">Regex</option></select><input type="text" placeholder="e.g. 4K, Sport, Movie"><button onclick="removePattern(this)">X</button></div>';
            } else {
                container.innerHTML = patterns.map(p => '<div class="pattern-row"><select>' + ['contains', 'not_contains', 'starts_with', 'ends_with', 'exact', 'regex'].map(m => '<option value="' + m + '"' + (p.match === m ? ' selected' : '') + '>' + {'contains':'Contains','not_contains':'Does not contain','starts_with':'Starts with','ends_with':'Ends with','exact':'Exact match','regex':'Regex'}[m] + '</option>').join('') + '</select><input type="text" value="' + escapeHtml(p.value) + '"><button onclick="removePattern(this)">X</button></div>').join('');
            }
        }

        function addPattern() {
            const container = document.getElementById('patterns-container');
            const newRow = document.createElement('div');
            newRow.className = 'pattern-row';
            newRow.innerHTML = '<select><option value="contains">Contains</option><option value="not_contains">Does not contain</option><option value="starts_with">Starts with</option><option value="ends_with">Ends with</option><option value="exact">Exact match</option><option value="regex">Regex</option></select><input type="text" placeholder="e.g. 4K, Sport, Movie"><button onclick="removePattern(this)">X</button>';
            container.appendChild(newRow);
        }

        function removePattern(btn) {
            const container = document.getElementById('patterns-container');
            if (container.children.length > 1) btn.parentElement.remove();
        }

        async function saveCategory() {
            const editId = document.getElementById('category-edit-id').value;
            const name = document.getElementById('category-name').value.trim();
            const icon = document.querySelector('.icon-option.selected')?.dataset.icon || 'folder';
            const mode = document.querySelector('.mode-option.selected')?.dataset.mode || 'manual';
            const contentTypes = Array.from(document.querySelectorAll('.content-type-checkbox.selected')).map(cb => cb.dataset.type);
            const patternLogic = document.getElementById('pattern-logic').value;
            const useSourceFilters = document.getElementById('use-source-filters').checked;
            const notifyTelegram = document.getElementById('notify-telegram').checked;
            const useRecentlyAdded = document.getElementById('use-recently-added').checked;
            const recentlyAddedDays = useRecentlyAdded ? parseInt(document.getElementById('recently-added-days').value) : 0;
            const patterns = Array.from(document.querySelectorAll('#patterns-container .pattern-row')).map(row => ({
                match: row.querySelector('select').value,
                value: row.querySelector('input').value,
                case_sensitive: false
            })).filter(p => p.value.trim());

            const data = { name, icon, mode, content_types: contentTypes, patterns, pattern_logic: patternLogic, use_source_filters: useSourceFilters, notify_telegram: notifyTelegram, recently_added_days: recentlyAddedDays };

            // Show spinner on save button
            const saveBtn = document.querySelector('#category-modal .btn-primary');
            const originalText = saveBtn.textContent;
            saveBtn.disabled = true;
            saveBtn.innerHTML = '<span class="loading-spinner" style="width:16px;height:16px;border-width:2px;display:inline-block;vertical-align:middle;margin-right:6px;"></span>Saving‚Ä¶';

            try {
                const url = editId ? '/api/categories/' + editId : '/api/categories';
                const method = editId ? 'PUT' : 'POST';
                const response = await fetch(url, { method, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) });
                const result = await response.json();
                const savedCategoryId = result.category ? result.category.id : editId;

                if (mode === 'automatic') {
                    saveBtn.innerHTML = '<span class="loading-spinner" style="width:16px;height:16px;border-width:2px;display:inline-block;vertical-align:middle;margin-right:6px;"></span>Refreshing items‚Ä¶';
                    await fetch('/api/categories/refresh', { method: 'POST' });
                }

                closeCategoryModal();
                await loadCategories();

                // Auto-select the saved category and refresh the items grid
                if (savedCategoryId) {
                    selectedCategoryId = savedCategoryId;
                    document.getElementById('controls-bar').style.display = 'none';
                    renderBrowseNav();
                    currentPage = 1;
                    await applyFilters();
                }
            } catch (error) {
                console.error('Error saving category:', error);
                alert('Failed to save category');
            } finally {
                saveBtn.disabled = false;
                saveBtn.textContent = originalText;
            }
        }

        function openManageCategoriesModal() {
            const container = document.getElementById('categories-manage-list');
            container.innerHTML = categories.map(cat => {
                const icon = iconMap[cat.icon] || cat.icon || 'üìÅ';
                const count = cat.mode === 'automatic' ? (cat.cached_items || []).length : (cat.items || []).length;
                return '<div class="category-manage-item"><div class="category-manage-info"><span class="icon">' + icon + '</span><div><div class="name">' + escapeHtml(cat.name) + '</div><div class="meta">' + cat.mode + ' - ' + count + ' items</div></div></div><div class="category-manage-actions"><button class="btn btn-small btn-secondary" onclick="closeManageCategoriesModal(); openCategoryModal(\'' + cat.id + '\')">Edit</button><button class="btn btn-small btn-danger" onclick="deleteCategory(\'' + cat.id + '\')">Delete</button></div></div>';
            }).join('') || '<p style="color:#888">No categories yet</p>';
            document.getElementById('manage-modal').classList.add('show');
        }

        function closeManageCategoriesModal() { document.getElementById('manage-modal').classList.remove('show'); }

        async function deleteCategory(categoryId) {
            try {
                await fetch('/api/categories/' + categoryId, { method: 'DELETE' });
                await loadCategories();
                if (selectedCategoryId === categoryId) { selectedCategoryId = null; document.querySelector('#controls-bar > .controls-row:first-child').style.display = 'flex'; document.getElementById('sort-filter-row').style.display = (contentType === 'vod' || contentType === 'series') ? 'flex' : 'none'; applyFilters(); }
                renderBrowseNav();
                openManageCategoriesModal();
            } catch (error) { console.error('Error deleting category:', error); }
        }

        function updatePagination() {
            const pagination = document.getElementById('pagination');
            pagination.style.display = totalPages > 1 ? 'flex' : 'none';
            document.getElementById('current-page').textContent = currentPage;
            document.getElementById('total-pages').textContent = totalPages;
            document.getElementById('first-page-btn').disabled = currentPage === 1;
            document.getElementById('prev-page-btn').disabled = currentPage === 1;
            document.getElementById('next-page-btn').disabled = currentPage === totalPages;
            document.getElementById('last-page-btn').disabled = currentPage === totalPages;
        }

        function goToPage(page) {
            if (page < 1 || page > totalPages) return;
            currentPage = page;
            applyFilters();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function isRecent(timestamp, days) {
            if (!timestamp) return false;
            const date = new Date(timestamp * 1000);
            const now = new Date();
            const diffDays = (now - date) / (1000 * 60 * 60 * 24);
            return diffDays <= days;
        }

        function formatDate(timestamp) {
            if (!timestamp) return '';
            const date = new Date(timestamp * 1000);
            return date.toLocaleDateString();
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function jsEscape(str) {
            return String(str || '').replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '');
        }

        function escapeAttr(str) {
            return String(str || '').replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }

        loadGroups();

        // ============================================
        // DOWNLOAD CART FUNCTIONS
        // ============================================
        let _episodeModalData = {};  // { sourceId, seriesId, seriesName, icon, group, episodes }

        async function updateCartBadge() {
            try {
                const resp = await fetch('/api/cart/status');
                const data = await resp.json();
                const badge = document.getElementById('cart-badge');
                const count = data.queued + data.downloading;
                if (count > 0) {
                    badge.textContent = count;
                    badge.style.display = 'flex';
                } else {
                    badge.style.display = 'none';
                }
            } catch (e) {}
        }

        // Delegated click handler for all cart buttons
        document.addEventListener('click', function(event) {
            const btn = event.target.closest('.add-cart-btn');
            if (!btn) return;
            event.stopPropagation();
            event.preventDefault();
            const sourceId = btn.dataset.sourceId;
            const itemId = btn.dataset.itemId;
            const cType = btn.dataset.contentType;
            const name = btn.dataset.name;
            const icon = btn.dataset.icon;
            const group = btn.dataset.group;
            const ext = btn.dataset.ext || 'mp4';
            const allSourcesRaw = btn.dataset.allSources;
            let allSources = null;
            if (allSourcesRaw) {
                try { allSources = JSON.parse(allSourcesRaw); } catch(e) {}
            }
            _handleCartAdd(sourceId, itemId, cType, name, icon, group, allSources, ext);
        });

        async function _handleCartAdd(sourceId, itemId, cType, name, icon, group, allSources, ext) {
            if (cType === 'series') {
                // Open episode selector modal
                openEpisodeModal(sourceId, itemId, name, icon, group, allSources);
                return;
            }
            // VOD: if multiple sources, show source selector modal
            if (cType === 'vod' && allSources && allSources.length > 1) {
                openVodSourceModal(allSources, name);
                return;
            }
            // VOD single source: add directly
            await _addVodToCart(sourceId, itemId, name, icon, group, ext);
        }

        async function _addVodToCart(sourceId, itemId, name, icon, group, ext) {
            try {
                const resp = await fetch('/api/cart', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        source_id: sourceId,
                        stream_id: itemId,
                        content_type: 'vod',
                        name: name,
                        icon: icon,
                        group: group,
                        container_extension: ext || 'mp4'
                    })
                });
                const data = await resp.json();
                if (resp.ok) {
                    showToast('Added to cart: ' + name, 'success');
                    updateCartBadge();
                } else {
                    showToast(data.error || 'Failed to add', 'error');
                }
            } catch (e) { showToast('Error adding to cart', 'error'); }
        }

        function openVodSourceModal(allSources, name) {
            const modal = document.getElementById('vod-source-modal');
            document.getElementById('vod-source-modal-title').textContent = 'Select Source: ' + name;
            const listEl = document.getElementById('vod-source-list');
            listEl.innerHTML = allSources.map((s, idx) => {
                const si = sources.findIndex(src => src.id === s.source_id) + 1;
                return '<div style="display:flex; justify-content:space-between; align-items:center; padding:12px; border-radius:8px; margin-bottom:8px; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); cursor:pointer; transition:all 0.2s;" ' +
                    'onmouseenter="this.style.borderColor=\'#00d4ff\'" onmouseleave="this.style.borderColor=\'rgba(255,255,255,0.1)\'" ' +
                    'onclick="selectVodSource(' + idx + ')">' +
                    '<div>' +
                    '<div style="font-weight:500;">' + escapeHtml(s.name) + '</div>' +
                    '<span class="source-badge" data-color="' + (si % 5 || 5) + '">' + escapeHtml(s.source_name) + '</span>' +
                    (s.group ? ' <span style="font-size:0.8em;color:#888;">' + escapeHtml(s.group) + '</span>' : '') +
                    '</div>' +
                    '<span style="font-size:1.2em;">üõí</span>' +
                    '</div>';
            }).join('');
            modal.classList.add('show');
            modal._allSources = allSources;
        }

        function closeVodSourceModal() {
            document.getElementById('vod-source-modal').classList.remove('show');
        }

        async function selectVodSource(idx) {
            const modal = document.getElementById('vod-source-modal');
            const s = modal._allSources[idx];
            closeVodSourceModal();
            await _addVodToCart(s.source_id, s.item_id, s.name, s.icon || '', s.group || '', s.container_extension || 'mp4');
        }

        async function openEpisodeModal(sourceId, seriesId, seriesName, icon, group, allSources) {
            const modal = document.getElementById('episode-modal');
            document.getElementById('episode-modal-title').textContent = 'Select Episodes: ' + seriesName;
            document.getElementById('episode-list').innerHTML = '<div class="loading"><div class="loading-spinner"></div><p>Loading episodes...</p></div>';
            modal.classList.add('show');

            _episodeModalData = { sourceId, seriesId, seriesName, icon, group, allSources: allSources || null };

            // Show/build source selector if multiple sources available
            const selectorDiv = document.getElementById('episode-source-selector');
            const selectEl = document.getElementById('episode-source-select');
            if (allSources && allSources.length > 1) {
                selectEl.innerHTML = allSources.map(s =>
                    '<option value="' + escapeAttr(s.source_id) + '|' + escapeAttr(s.item_id) + '|' + escapeAttr(s.name) + '|' + escapeAttr(s.icon) + '|' + escapeAttr(s.group) + '"' + (s.source_id === sourceId ? ' selected' : '') + '>' + escapeHtml(s.source_name) + ' ‚Äî ' + escapeHtml(s.name) + '</option>'
                ).join('');
                selectorDiv.style.display = 'flex';
            } else {
                selectorDiv.style.display = 'none';
            }

            await _loadEpisodesForSource(sourceId, seriesId);
        }

        async function _loadEpisodesForSource(sourceId, seriesId) {
            document.getElementById('episode-list').innerHTML = '<div class="loading"><div class="loading-spinner"></div><p>Loading episodes...</p></div>';
            _episodeModalData.sourceId = sourceId;
            _episodeModalData.seriesId = seriesId;

            try {
                const resp = await fetch('/api/cart/series-episodes/' + sourceId + '/' + seriesId);
                const data = await resp.json();
                if (!resp.ok || !data.seasons) {
                    document.getElementById('episode-list').innerHTML = '<p style="color:#ff4757">Failed to load episodes: ' + (data.error || 'Unknown error') + '</p>';
                    return;
                }
                _episodeModalData.episodes = data;
                renderEpisodeList(data);
            } catch (e) {
                document.getElementById('episode-list').innerHTML = '<p style="color:#ff4757">Error loading episodes</p>';
            }
        }

        function onEpisodeSourceChange() {
            const val = document.getElementById('episode-source-select').value;
            const parts = val.split('|');
            const sourceId = parts[0];
            const seriesId = parts[1];
            const name = parts[2] || _episodeModalData.seriesName;
            const icon = parts[3] || _episodeModalData.icon;
            const grp = parts[4] || _episodeModalData.group;
            _episodeModalData.icon = icon;
            _episodeModalData.group = grp;
            _loadEpisodesForSource(sourceId, seriesId);
        }

        function renderEpisodeList(data) {
            const container = document.getElementById('episode-list');
            const seasons = data.seasons;
            let html = '';

            for (const [seasonNum, episodes] of Object.entries(seasons)) {
                html += '<div class="season-group">';
                html += '<div class="season-header"><h4>Season ' + seasonNum + ' (' + episodes.length + ' episodes)</h4>';
                html += '<button onclick="addSeasonToCart(\'' + seasonNum + '\')">Add Season</button></div>';

                for (const ep of episodes) {
                    const epExt = ep.container_extension || 'mp4';
                    const epPlayBtn = '<button class="episode-play-btn" onclick="event.stopPropagation(); playEpisode(\'' + ep.stream_id + '\', \'' + escapeAttr(ep.title || 'Episode ' + ep.episode_num) + '\', \'' + epExt + '\')" title="Play episode">‚ñ∂ Play</button>';
                    html += '<div class="episode-row" onclick="playEpisode(\'' + ep.stream_id + '\', \'' + escapeAttr(ep.title || 'Episode ' + ep.episode_num) + '\', \'' + epExt + '\')">' +
                        '<input type="checkbox" onclick="event.stopPropagation()" data-season="' + seasonNum + '" data-stream-id="' + ep.stream_id + '" data-ep-num="' + ep.episode_num + '" data-title="' + escapeHtml(ep.title || '') + '" data-ext="' + epExt + '">' +
                        epPlayBtn +
                        '<span class="ep-num">E' + String(ep.episode_num).padStart(2, '0') + '</span>' +
                        '<span class="ep-title">' + escapeHtml(ep.title || 'Episode ' + ep.episode_num) + '</span>' +
                        '<span class="ep-ext">' + epExt + '</span>' +
                        '</div>';
                }
                html += '</div>';
            }
            container.innerHTML = html;
        }

        function playEpisode(streamId, title, ext) {
            const d = _episodeModalData;
            const sourceId = d.sourceId;
            const seriesName = d.seriesName || '';
            const icon = d.icon || '';
            const group = d.group || '';
            const fullTitle = seriesName ? seriesName + ' - ' + title : title;
            openPlayer('series', sourceId, streamId, fullTitle, icon, group, ext);
        }

        function closeEpisodeModal() {
            document.getElementById('episode-modal').classList.remove('show');
            _episodeModalData = {};
        }

        async function addAllEpisodesToCart() {
            const d = _episodeModalData;
            try {
                const resp = await fetch('/api/cart', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        source_id: d.sourceId,
                        series_id: d.seriesId,
                        content_type: 'series',
                        add_mode: 'series',
                        name: d.seriesName,
                        series_name: d.seriesName,
                        icon: d.icon,
                        group: d.group
                    })
                });
                const data = await resp.json();
                if (resp.ok) {
                    showToast('Added ' + data.added + ' episodes to cart', 'success');
                    updateCartBadge();
                    closeEpisodeModal();
                } else {
                    showToast(data.error || 'Failed to add episodes', 'error');
                }
            } catch (e) { showToast('Error adding episodes', 'error'); }
        }

        async function addSeasonToCart(seasonNum) {
            const d = _episodeModalData;
            try {
                const resp = await fetch('/api/cart', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        source_id: d.sourceId,
                        series_id: d.seriesId,
                        content_type: 'series',
                        add_mode: 'season',
                        season_num: seasonNum,
                        name: d.seriesName,
                        series_name: d.seriesName,
                        icon: d.icon,
                        group: d.group
                    })
                });
                const data = await resp.json();
                if (resp.ok) {
                    showToast('Added ' + data.added + ' episodes (Season ' + seasonNum + ') to cart', 'success');
                    updateCartBadge();
                } else {
                    showToast(data.error || 'Failed to add season', 'error');
                }
            } catch (e) { showToast('Error adding season', 'error'); }
        }

        async function addSelectedEpisodesToCart() {
            const d = _episodeModalData;
            const checked = document.querySelectorAll('#episode-list input[type="checkbox"]:checked');
            if (checked.length === 0) { showToast('No episodes selected', 'info'); return; }

            let addedCount = 0;
            for (const cb of checked) {
                try {
                    const resp = await fetch('/api/cart', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            source_id: d.sourceId,
                            stream_id: cb.dataset.streamId,
                            content_type: 'series',
                            add_mode: 'episode',
                            name: cb.dataset.title || 'Episode ' + cb.dataset.epNum,
                            series_name: d.seriesName,
                            season: cb.dataset.season,
                            episode_num: parseInt(cb.dataset.epNum),
                            episode_title: cb.dataset.title,
                            icon: d.icon,
                            group: d.group,
                            container_extension: cb.dataset.ext || 'mp4'
                        })
                    });
                    if (resp.ok) addedCount++;
                } catch (e) {}
            }
            showToast('Added ' + addedCount + ' episodes to cart', 'success');
            updateCartBadge();
            closeEpisodeModal();
        }

        // Load cart badge on page load
        updateCartBadge();

        function checkVersion() {
            fetch('/api/version').then(r => r.json()).then(data => {
                const badge = document.getElementById('version-badge');
                if (!badge) return;
                if (data.update_available) {
                    badge.textContent = 'v' + data.current + ' ‚Üí v' + data.latest;
                    badge.style.background = 'rgba(255, 165, 0, 0.15)';
                    badge.style.color = '#ffa500';
                    badge.style.cursor = 'pointer';
                    badge.title = 'Click to view release notes';
                    badge.onclick = function() { window.open(data.release_url, '_blank'); };
                } else {
                    badge.textContent = 'v' + data.current;
                }
                badge.style.display = 'inline-block';
            }).catch(() => {});
        }
        checkVersion();

        // ============================================
        // SERIES MONITOR FUNCTIONS
        // ============================================
        let _monitorModalData = {};

        function openMonitorModal(event, sourceId, seriesId, seriesName, icon, sourceName, allSources) {
            event.stopPropagation();
            event.preventDefault();

            _monitorModalData = {
                sourceId: sourceId,
                seriesId: seriesId,
                seriesName: seriesName,
                icon: icon || '',
                sourceName: sourceName || '',
                allSources: allSources || null,
            };

            const modal = document.getElementById('monitor-modal');
            document.getElementById('monitor-modal-title').textContent = 'üì° Monitor: ' + seriesName;

            // Reset scope
            selectMonitorScope('new_only');
            document.getElementById('monitor-season-group').style.display = 'none';

            // Reset action
            selectMonitorAction('both');

            // Build source options
            const sourceContainer = document.getElementById('monitor-source-options');
            let sourceHtml = '<div class="source-option selected" data-source="any" onclick="selectMonitorSource(\'any\')">Any source (first found)</div>';

            if (allSources && allSources.length > 0) {
                for (const s of allSources) {
                    const sourceKey = s.source_id + '|' + s.series_id;
                    const catLabel = s.category ? ' <span style="opacity:0.5;font-size:0.85em">(' + escapeHtml(s.category) + ')</span>' : '';
                    sourceHtml += '<div class="source-option" data-source-key="' + escapeAttr(sourceKey) + '" data-source="' + escapeAttr(s.source_id) + '" data-series-id="' + escapeAttr(s.series_id) + '" data-source-name="' + escapeAttr(s.source_name) + '" data-category="' + escapeAttr(s.category || '') + '" onclick="selectMonitorSource(\'' + escapeAttr(sourceKey) + '\')">' + escapeHtml(s.source_name) + catLabel + '</div>';
                }
            } else if (sourceId) {
                const sourceKey = sourceId + '|' + seriesId;
                sourceHtml += '<div class="source-option" data-source-key="' + escapeAttr(sourceKey) + '" data-source="' + escapeAttr(sourceId) + '" data-series-id="' + escapeAttr(seriesId) + '" data-source-name="' + escapeAttr(sourceName || '') + '" data-category="" onclick="selectMonitorSource(\'' + escapeAttr(sourceKey) + '\')">' + escapeHtml(sourceName || sourceId) + '</div>';
            }
            sourceContainer.innerHTML = sourceHtml;

            // Load season list for season scope (aggregate from all sources)
            _loadSeasonsList(sourceId, seriesId, allSources);

            modal.classList.add('show');
        }

        async function _loadSeasonsList(sourceId, seriesId, allSources) {
            const seasonSelect = document.getElementById('monitor-season-select');
            seasonSelect.innerHTML = '<option value="">Loading...</option>';

            // Build list of source/series pairs to query
            const pairs = [];
            if (allSources && allSources.length > 0) {
                for (const s of allSources) pairs.push({ sourceId: s.source_id, seriesId: s.series_id });
            } else if (sourceId && seriesId) {
                pairs.push({ sourceId, seriesId });
            }
            if (pairs.length === 0) return;

            try {
                // Fetch episodes from all sources in parallel
                const results = await Promise.allSettled(
                    pairs.map(p => fetch('/api/cart/series-episodes/' + p.sourceId + '/' + p.seriesId).then(r => r.json()))
                );
                // Merge seasons: keep the max episode count per season across sources
                const mergedSeasons = {};
                for (const r of results) {
                    if (r.status !== 'fulfilled' || !r.value.seasons) continue;
                    for (const [sNum, eps] of Object.entries(r.value.seasons)) {
                        if (!mergedSeasons[sNum] || eps.length > mergedSeasons[sNum]) {
                            mergedSeasons[sNum] = eps.length;
                        }
                    }
                }
                const seasonNums = Object.keys(mergedSeasons).sort((a, b) => parseInt(a) - parseInt(b));
                if (seasonNums.length > 0) {
                    seasonSelect.innerHTML = seasonNums.map(s => '<option value="' + s + '">Season ' + s + ' (' + mergedSeasons[s] + ' episodes)</option>').join('');
                } else {
                    seasonSelect.innerHTML = '<option value="">No seasons found</option>';
                }
            } catch (e) {
                seasonSelect.innerHTML = '<option value="">Error loading seasons</option>';
            }
        }

        function selectMonitorScope(scope) {
            document.querySelectorAll('#monitor-modal .scope-option').forEach(o => {
                o.classList.toggle('selected', o.dataset.scope === scope);
            });
            document.getElementById('monitor-season-group').style.display = scope === 'season' ? 'block' : 'none';
            _monitorModalData.scope = scope;
        }

        function selectMonitorSource(sourceKey) {
            document.querySelectorAll('#monitor-modal .source-option').forEach(o => {
                const key = o.dataset.sourceKey || o.dataset.source;
                o.classList.toggle('selected', key === sourceKey);
            });
            _monitorModalData.selectedSource = sourceKey;
        }

        function selectMonitorAction(action) {
            document.querySelectorAll('#monitor-modal .action-option').forEach(o => {
                o.classList.toggle('selected', o.dataset.action === action);
            });
            _monitorModalData.action = action;
        }

        function closeMonitorModal() {
            document.getElementById('monitor-modal').classList.remove('show');
            _monitorModalData = {};
        }

        async function confirmMonitor() {
            const d = _monitorModalData;
            const scope = d.scope || 'new_only';
            const selectedSource = d.selectedSource || 'any';
            const seasonFilter = scope === 'season' ? document.getElementById('monitor-season-select').value : null;

            if (scope === 'season' && !seasonFilter) {
                showToast('Please select a season', 'error');
                return;
            }

            let sourceId = null;
            let sourceName = null;
            let sourceCategory = null;
            let seriesId = d.seriesId;

            if (selectedSource !== 'any') {
                // selectedSource is a composite key "source_id|series_id" or just a source_id
                const sourceOption = document.querySelector('#monitor-modal .source-option.selected');
                if (sourceOption) {
                    sourceId = sourceOption.dataset.source;
                    sourceName = sourceOption.dataset.sourceName || sourceOption.textContent.trim();
                    sourceCategory = sourceOption.dataset.category || null;
                    if (sourceOption.dataset.seriesId) seriesId = sourceOption.dataset.seriesId;
                }
            }

            try {
                const resp = await fetch('/api/monitor', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        series_name: d.seriesName,
                        series_id: seriesId,
                        source_id: sourceId,
                        source_name: sourceName,
                        source_category: sourceCategory,
                        cover: d.icon,
                        scope: scope,
                        season_filter: seasonFilter,
                        action: d.action || 'both',
                    })
                });
                const data = await resp.json();
                if (resp.ok) {
                    showToast('Monitoring started: ' + d.seriesName, 'success');
                    closeMonitorModal();
                } else {
                    showToast(data.error || 'Failed to add monitoring', 'error');
                }
            } catch (e) {
                showToast('Error adding monitoring', 'error');
            }
        }
    </script>
</body>
</html>
